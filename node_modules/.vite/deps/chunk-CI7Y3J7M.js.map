{
  "version": 3,
  "sources": ["../../@most/prelude/src/array.ts", "../../@most/prelude/src/function.ts", "../../@most/scheduler/src/ScheduledTask.ts", "../../@most/scheduler/src/RelativeScheduler.ts", "../../@most/scheduler/src/task.ts", "../../@most/scheduler/src/Scheduler.ts", "../../@most/scheduler/src/Timeline.ts", "../../@most/scheduler/src/ClockTimer.ts", "../../@most/scheduler/src/clock.ts", "../../@most/scheduler/src/schedule.ts", "../../@most/scheduler/src/relative.ts", "../../@most/scheduler/src/index.ts", "../../@most/disposable/src/dispose.ts", "../../@most/disposable/src/disposeNone.ts", "../../@most/disposable/src/disposeOnce.ts", "../../@most/disposable/src/disposeWith.ts", "../../@most/disposable/src/disposeAll.ts", "../../@most/disposable/src/tryDispose.ts", "../../@most/core/src/fatalError.ts", "../../@most/core/src/scheduler/PropagateTask.ts", "../../@most/core/src/source/empty.ts", "../../@most/core/src/source/never.ts", "../../@most/core/src/source/at.ts", "../../@most/core/src/source/now.ts", "../../@most/core/src/source/periodic.ts", "../../@most/core/src/source/newStream.ts", "../../@most/core/src/disposable/SettableDisposable.ts", "../../@most/core/src/runEffects.ts", "../../@most/core/src/run.ts", "../../@most/core/src/sink/RelativeSink.ts", "../../@most/core/src/combinator/withLocalTime.ts", "../../@most/core/src/sink/Pipe.ts", "../../@most/core/src/combinator/loop.ts", "../../@most/core/src/combinator/scan.ts", "../../@most/core/src/combinator/continueWith.ts", "../../@most/core/src/combinator/startWith.ts", "../../@most/core/src/fusion/Filter.ts", "../../@most/core/src/fusion/FilterMap.ts", "../../@most/core/src/fusion/Map.ts", "../../@most/core/src/combinator/transform.ts", "../../@most/core/src/sink/IndexSink.ts", "../../@most/core/src/invoke.ts", "../../@most/core/src/combinator/combine.ts", "../../@most/core/src/combinator/applicative.ts", "../../@most/core/src/combinator/mergeConcurrently.ts", "../../@most/core/src/combinator/chain.ts", "../../@most/core/src/combinator/concatMap.ts", "../../@most/core/src/combinator/merge.ts", "../../@most/core/src/combinator/snapshot.ts", "../../@most/core/src/combinator/slice/bounds.ts", "../../@most/core/src/combinator/slice/index.ts", "../../@most/core/src/combinator/zipItems.ts", "../../@most/core/src/Queue.ts", "../../@most/core/src/combinator/zip.ts", "../../@most/core/src/combinator/switch.ts", "../../@most/core/src/combinator/filter.ts", "../../@most/core/src/combinator/timeslice.ts", "../../@most/core/src/combinator/delay.ts", "../../@most/core/src/combinator/limit.ts", "../../@most/core/src/combinator/promises.ts", "../../@most/core/src/sink/SafeSink.ts", "../../@most/core/src/source/tryEvent.ts", "../../@most/core/src/combinator/errors.ts", "../../@most/core/src/combinator/multicast.ts", "../../@most/core/src/index.ts"],
  "sourcesContent": ["/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\n// Non-mutating array operations\n\n/**\n * a with x prepended\n */\nexport function cons <A>(x: A, a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l + 1)\n  b[0] = x\n  for (let i = 0; i < l; ++i) {\n    b[i + 1] = a[i]\n  }\n  return b\n}\n\n/**\n * a with x appended\n */\nexport function append <A>(x: A, a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l + 1)\n  for (let i = 0; i < l; ++i) {\n    b[i] = a[i]\n  }\n\n  b[l] = x\n  return b\n}\n\n/**\n * Concats two `ArrayLike`s\n */\nexport function concat <A>(a: ArrayLike<A>, b: ArrayLike<A>): A[] {\n  const al = a.length\n  const bl = b.length\n  const r = new Array(al + bl)\n  let i = 0\n  for (i = 0; i < al; i++) {\n    r[i] = a[i]\n  }\n  for (let j = 0; j < bl; j++) {\n    r[i++] = b[j]\n  }\n  return r\n}\n\n//\n/**\n * drop first n elements\n */\nexport function drop <A>(n: number, a: A[]): A[] {\n  if (n < 0) {\n    throw new TypeError('n must be >= 0')\n  }\n\n  const l = a.length\n  if (n === 0 || l === 0) {\n    return a\n  }\n\n  if (n >= l) {\n    return []\n  }\n\n  return unsafeDrop(n, a, l - n)\n}\n\n/**\n * Internal helper for drop\n */\nfunction unsafeDrop <A>(n: number, a: ArrayLike<A>, l: number): A[] {\n  const b = new Array(l)\n  for (let i = 0; i < l; ++i) {\n    b[i] = a[n + i]\n  }\n  return b\n}\n\n/**\n * drop head element\n */\nexport function tail <A>(a: A[]): A[] {\n  return drop(1, a)\n}\n\n/**\n * duplicate a (shallow duplication)\n */\nexport function copy <A>(a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l)\n  for (let i = 0; i < l; ++i) {\n    b[i] = a[i]\n  }\n  return b\n}\n\n/**\n * transform each element with f\n */\nexport function map <A, B>(f: (a: A) => B, a: ArrayLike<A>): B[] {\n  const l = a.length\n  const b = new Array(l)\n  for (let i = 0; i < l; ++i) {\n    b[i] = f(a[i])\n  }\n  return b\n}\n\n/**\n * accumulate via left-fold\n */\nexport function reduce <A, B>(f: (a: A, b: B, i: number) => A, z: A, a: ArrayLike<B>): A {\n  let r = z\n  for (let i = 0, l = a.length; i < l; ++i) {\n    r = f(r, a[i], i)\n  }\n  return r\n}\n\n/**\n * replace element at index\n */\nexport function replace <A>(x: A, i: number, a: ArrayLike<A>): A[] {\n  if (i < 0) {\n    throw new TypeError('i must be >= 0')\n  }\n\n  const l = a.length\n  const b = new Array(l)\n  for (let j = 0; j < l; ++j) {\n    b[j] = i === j ? x : a[j]\n  }\n  return b\n}\n\n/**\n * remove element at index\n * @throws\n */\nexport function remove <A>(i: number, a: A[]): A[] {\n  if (i < 0) {\n    throw new TypeError('i must be >= 0')\n  }\n\n  const l = a.length\n  if (l === 0 || i >= l) { // exit early if index beyond end of array\n    return a\n  }\n\n  if (l === 1) { // exit early if index in bounds and length === 1\n    return []\n  }\n\n  return unsafeRemove(i, a, l - 1)\n}\n\n/**\n * Internal helper to remove element at index\n */\nfunction unsafeRemove <A>(i: number, a: ArrayLike<A>, l: number): A[] {\n  const b = new Array(l)\n  let j\n  for (j = 0; j < i; ++j) {\n    b[j] = a[j]\n  }\n  for (j = i; j < l; ++j) {\n    b[j] = a[j + 1]\n  }\n\n  return b\n}\n\n/**\n * remove all elements matching a predicate\n * @deprecated\n */\nexport function removeAll <A>(f: (a: A) => boolean, a: ArrayLike<A>): A[] {\n  const l = a.length\n  const b = new Array(l)\n  let j = 0\n  for (let x, i = 0; i < l; ++i) {\n    x = a[i]\n    if (!f(x)) {\n      b[j] = x\n      ++j\n    }\n  }\n\n  b.length = j\n  return b\n}\n\n/**\n * find index of x in a, from the left\n */\nexport function findIndex <A>(x: A, a: ArrayLike<A>): number {\n  for (let i = 0, l = a.length; i < l; ++i) {\n    if (x === a[i]) {\n      return i\n    }\n  }\n  return -1\n}\n\n/**\n * Return true iff x is array-like\n */\nexport function isArrayLike(x: any): x is ArrayLike<unknown> {\n  return x != null && typeof x.length === 'number' && typeof x !== 'function'\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n\nexport const id = <A>(x: A): A => x\n\nexport const compose = <A, B, C>(f: (b: B) => C, g: (a: A) => B) => (x: A): C => f(g(x))\n\nexport const apply = <A, B>(f: (a: A) => B, x: A): B => f(x)\n\nexport interface Curried2<A, B, C> {\n  (): Curried2<A, B, C>\n  (a: A, b: B): C\n  (a: A): (b: B) => C\n}\n\nexport function curry2 <A, B, C>(f: (a: A, b: B) => C): Curried2<A, B, C> {\n  function curried(a: A, b: B): any {\n    switch (arguments.length) {\n      case 0: return curried\n      case 1: return (b: B) => f(a, b)\n      default: return f(a, b)\n    }\n  }\n  return curried as any\n}\n\nexport interface Curried3<A, B, C, D> {\n  (): Curried3<A, B, C, D>\n  (a: A): Curried2<B, C, D>\n  (a: A, b: B): (c: C) => D\n  (a: A, b: B, c: C): D\n}\n\nexport function curry3 <A, B, C, D>(f: (a: A, b: B, c: C) => D): Curried3<A, B, C, D> {\n  function curried(a: A, b: B, c: C): any {\n    switch (arguments.length) {\n      case 0: return curried\n      case 1: return curry2((b: B, c: C) => f(a, b, c))\n      case 2: return (c: C) => f(a, b, c)\n      default:return f(a, b, c)\n    }\n  }\n  return curried as any\n}\n\nexport interface Curried4<A, B, C, D, E> {\n  (): Curried4<A, B, C, D, E>\n  (a: A): Curried3<B, C, D, E>\n  (a: A, b: B): Curried2<C, D, E>\n  (a: A, b: B, c: C): (d: D) => E\n  (a: A, b: B, c: C, d: D): E\n}\n\nexport function curry4 <A, B, C, D, E>(f: (a: A, b: B, c: C, d: D) => E): Curried4<A, B, C, D, E> {\n  function curried(a: A, b: B, c: C, d: D): any {\n    switch (arguments.length) {\n      case 0: return curried\n      case 1: return curry3((b: B, c: C, d: D) => f(a, b, c, d))\n      case 2: return curry2((c: C, d: D) => f(a, b, c, d))\n      case 3: return (d: D) => f(a, b, c, d)\n      default:return f(a, b, c, d)\n    }\n  }\n  return curried as any\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { ScheduledTask, Time, Task, Scheduler } from '@most/types'\n\nexport default class ScheduledTaskImpl implements ScheduledTask {\n  /**\n   * @mutable\n   */\n  time: Time;\n  readonly localOffset: Time;\n  readonly period: Time;\n  readonly task: Task;\n  readonly scheduler: Scheduler;\n  /**\n   * @mutable\n   */\n  active: boolean;\n\n  constructor(time: Time, localOffset: Time, period: Time, task: Task, scheduler: Scheduler) {\n    this.time = time\n    this.localOffset = localOffset\n    this.period = period\n    this.task = task\n    this.scheduler = scheduler\n    this.active = true\n  }\n\n  run(): void {\n    return this.task.run(this.time - this.localOffset)\n  }\n\n  error(e: Error): void {\n    return this.task.error(this.time - this.localOffset, e)\n  }\n\n  dispose(): void {\n    this.active = false\n    this.scheduler.cancel(this)\n    return this.task.dispose()\n  }\n}\n", "import { Scheduler, Time, Task, ScheduledTask } from '@most/types'\n\nexport default class RelativeScheduler implements Scheduler {\n  readonly origin: Time;\n  readonly scheduler: Scheduler;\n\n  constructor(origin: Time, scheduler: Scheduler) {\n    this.origin = origin\n    this.scheduler = scheduler\n  }\n\n  currentTime(): Time {\n    return this.scheduler.currentTime() - this.origin\n  }\n\n  scheduleTask(localOffset: Time, delay: Time, period: Time, task: Task): ScheduledTask {\n    return this.scheduler.scheduleTask(localOffset + this.origin, delay, period, task)\n  }\n\n  relative(origin: Time): Scheduler {\n    return new RelativeScheduler(origin + this.origin, this.scheduler)\n  }\n\n  cancel(task: ScheduledTask): void {\n    return this.scheduler.cancel(task)\n  }\n\n  cancelAll(f: (task: ScheduledTask) => boolean): void {\n    return this.scheduler.cancelAll(f)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nexport interface DeferrableTask<E, A> {\n  run(): A\n  error(e: Error): E\n}\n\nexport const defer = <E, A>(task: DeferrableTask<E, A>): Promise<E | A> =>\n  Promise.resolve(task).then(runTask)\n\nexport function runTask <E, A>(task: DeferrableTask<E, A>): E | A {\n  try {\n    return task.run()\n  } catch (e) {\n    return task.error(e)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport ScheduledTaskImpl from './ScheduledTask'\nimport RelativeScheduler from './RelativeScheduler'\nimport { runTask } from './task'\nimport { Scheduler, Time, Timer, Timeline, Task, ScheduledTask } from '@most/types'\n\nexport default class SchedulerImpl implements Scheduler {\n  private readonly timer: Timer\n  private readonly timeline: Timeline\n  private _timer: Time | null\n  private _nextArrival: Time;\n  private _runReadyTasksBound = () => this._runReadyTasks()\n\n  constructor(timer: Timer, timeline: Timeline) {\n    this.timer = timer\n    this.timeline = timeline\n\n    this._timer = null\n    this._nextArrival = Infinity\n  }\n\n  currentTime(): Time {\n    return this.timer.now()\n  }\n\n  scheduleTask(localOffset: Time, delay: Time, period: Time, task: Task): ScheduledTaskImpl {\n    const time = this.currentTime() + Math.max(0, delay)\n    const st = new ScheduledTaskImpl(time, localOffset, period, task, this)\n\n    this.timeline.add(st)\n    this._scheduleNextRun()\n    return st\n  }\n\n  relative(offset: Time): Scheduler {\n    return new RelativeScheduler(offset, this)\n  }\n\n  cancel(task: ScheduledTaskImpl): void {\n    task.active = false\n    if (this.timeline.remove(task)) {\n      this._reschedule()\n    }\n  }\n\n  // @deprecated\n  cancelAll(f: (task: ScheduledTask) => boolean): void {\n    this.timeline.removeAll(f)\n    this._reschedule()\n  }\n\n  _reschedule(): void {\n    if (this.timeline.isEmpty()) {\n      this._unschedule()\n    } else {\n      this._scheduleNextRun()\n    }\n  }\n\n  _unschedule(): void {\n    this.timer.clearTimer(this._timer)\n    this._timer = null\n  }\n\n  _scheduleNextRun(): void {\n    if (this.timeline.isEmpty()) {\n      return\n    }\n\n    const nextArrival = this.timeline.nextArrival()\n\n    if (this._timer === null) {\n      this._scheduleNextArrival(nextArrival)\n    } else if (nextArrival < this._nextArrival) {\n      this._unschedule()\n      this._scheduleNextArrival(nextArrival)\n    }\n  }\n\n  _scheduleNextArrival(nextArrival: Time): void {\n    this._nextArrival = nextArrival\n    const delay = Math.max(0, nextArrival - this.currentTime())\n    this._timer = this.timer.setTimer(this._runReadyTasksBound, delay)\n  }\n\n  _runReadyTasks(): void {\n    this._timer = null\n    this.timeline.runTasks(this.currentTime(), runTask)\n    this._scheduleNextRun()\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { findIndex, removeAll } from '@most/prelude'\nimport { Time, Timeline } from '@most/types'\nimport ScheduledTaskImpl from './ScheduledTask'\n\nexport default class TimelineImpl implements Timeline {\n  private tasks: TimeSlot[];\n\n  constructor() {\n    this.tasks = []\n  }\n\n  nextArrival(): number {\n    return this.isEmpty() ? Infinity : this.tasks[0].time\n  }\n\n  isEmpty(): boolean {\n    return this.tasks.length === 0\n  }\n\n  add(st: ScheduledTaskImpl): void {\n    insertByTime(st, this.tasks)\n  }\n\n  remove(st: ScheduledTaskImpl): boolean {\n    const i = binarySearch(getTime(st), this.tasks)\n\n    if (i >= 0 && i < this.tasks.length) {\n      const events = this.tasks[i].events\n      const at = findIndex(st, events)\n      if (at >= 0) {\n        events.splice(at, 1)\n        if (events.length === 0) {\n          this.tasks.splice(i, 1)\n        }\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * @deprecated\n   */\n  removeAll(f: (task: ScheduledTaskImpl) => boolean): void {\n    for (let i = 0; i < this.tasks.length; ++i) {\n      removeAllFrom(f, this.tasks[i])\n    }\n  }\n\n  runTasks(t: Time, runTask: (task: ScheduledTaskImpl) => void): void {\n    const tasks = this.tasks\n    const l = tasks.length\n    let i = 0\n\n    while (i < l && tasks[i].time <= t) {\n      ++i\n    }\n\n    this.tasks = tasks.slice(i)\n\n    // Run all ready tasks\n    for (let j = 0; j < i; ++j) {\n      this.tasks = runReadyTasks(runTask, tasks[j].events, this.tasks)\n    }\n  }\n}\n\nfunction runReadyTasks(runTask: (task: ScheduledTaskImpl) => void, events: ArrayLike<ScheduledTaskImpl>, tasks: TimeSlot[]): TimeSlot[] {\n  for (let i = 0; i < events.length; ++i) {\n    const task = events[i]\n\n    if (task.active) {\n      runTask(task)\n\n      // Reschedule periodic repeating tasks\n      // Check active again, since a task may have canceled itself\n      if (task.period >= 0 && task.active) {\n        task.time = task.time + task.period\n        insertByTime(task, tasks)\n      }\n    }\n  }\n\n  return tasks\n}\n\nfunction insertByTime(task: ScheduledTaskImpl, timeslots: TimeSlot[]): void {\n  const l = timeslots.length\n  const time = getTime(task)\n\n  if (l === 0) {\n    timeslots.push(newTimeslot(time, [task]))\n    return\n  }\n\n  const i = binarySearch(time, timeslots)\n\n  if (i >= l) {\n    timeslots.push(newTimeslot(time, [task]))\n  } else {\n    insertAtTimeslot(task, timeslots, time, i)\n  }\n}\n\nfunction insertAtTimeslot(task: ScheduledTaskImpl, timeslots: TimeSlot[], time: Time, i: number): void {\n  const timeslot = timeslots[i]\n  if (time === timeslot.time) {\n    addEvent(task, timeslot.events)\n  } else {\n    timeslots.splice(i, 0, newTimeslot(time, [task]))\n  }\n}\n\nfunction addEvent(task: ScheduledTaskImpl, events: ScheduledTaskImpl[]): void {\n  if (events.length === 0 || task.time >= events[events.length - 1].time) {\n    events.push(task)\n  } else {\n    spliceEvent(task, events)\n  }\n}\n\nfunction spliceEvent(task: ScheduledTaskImpl, events: ScheduledTaskImpl[]): void {\n  for (let j = 0; j < events.length; j++) {\n    if (task.time < events[j].time) {\n      events.splice(j, 0, task)\n      break\n    }\n  }\n}\n\nfunction getTime(scheduledTask: ScheduledTaskImpl): Time {\n  return Math.floor(scheduledTask.time)\n}\n\n/**\n * @deprecated\n */\nfunction removeAllFrom(f: (task: ScheduledTaskImpl) => boolean, timeslot: TimeSlot): void {\n  timeslot.events = removeAll(f, timeslot.events)\n}\n\nfunction binarySearch(t: Time, sortedArray: ArrayLike<TimeSlot>): number {\n  let lo = 0\n  let hi = sortedArray.length\n  let mid, y\n\n  while (lo < hi) {\n    mid = Math.floor((lo + hi) / 2)\n    y = sortedArray[mid]\n\n    if (t === y.time) {\n      return mid\n    } else if (t < y.time) {\n      hi = mid\n    } else {\n      lo = mid + 1\n    }\n  }\n  return hi\n}\n\ninterface TimeSlot {\n  time: Time\n  events: ScheduledTaskImpl[]\n}\nconst newTimeslot = (t: Time, events: ScheduledTaskImpl[]): TimeSlot => ({ time: t, events: events })\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { defer, DeferrableTask } from './task'\nimport { Clock, Time, Timer } from '@most/types'\n\n/* global setTimeout, clearTimeout */\n\nexport default class ClockTimer implements Timer {\n  private _clock: Clock;\n  constructor(clock: Clock) {\n    this._clock = clock\n  }\n\n  now(): Time {\n    return this._clock.now()\n  }\n\n  setTimer <A>(f: () => A, dt: Time): NodeJS.Timeout | Asap<A> {\n    return dt <= 0 ? runAsap(f) : setTimeout(f, dt)\n  }\n\n  clearTimer <A>(t: number | Asap<A>): void {\n    return t instanceof Asap ? t.cancel() : clearTimeout(t)\n  }\n}\n\nclass Asap<A> implements DeferrableTask<never, A | undefined> {\n  private readonly f: () => A;\n  /**\n   * @mutable\n   */\n  public active: boolean;\n\n  constructor(f: () => A) {\n    this.f = f\n    this.active = true\n  }\n\n  run(): A | undefined {\n    if (this.active) {\n      return this.f()\n    }\n  }\n\n  error(e: Error): never {\n    throw e\n  }\n\n  cancel(): void {\n    this.active = false\n  }\n}\n\nfunction runAsap <A>(f: () => A): Asap<A> {\n  const task = new Asap(f)\n  defer(task)\n  return task\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Clock, Time } from '@most/types'\n\n/* global performance, process */\n\nexport class RelativeClock implements Clock {\n  private readonly clock: Clock;\n  private readonly origin: Time;\n  constructor(clock: Clock, origin: Time) {\n    this.origin = origin\n    this.clock = clock\n  }\n\n  now(): Time {\n    return this.clock.now() - this.origin\n  }\n}\n\nexport class HRTimeClock implements Clock {\n  private readonly hrtime: (time: [number, number]) => [number, number];\n  private readonly origin: [Time, Time];\n  constructor(hrtime: (time: [number, number]) => [number, number], origin: [Time, Time]) {\n    this.origin = origin\n    this.hrtime = hrtime\n  }\n\n  now(): Time {\n    const hrt = this.hrtime(this.origin)\n    return (hrt[0] * 1e9 + hrt[1]) / 1e6\n  }\n}\n\nexport const clockRelativeTo = (clock: Clock): Clock =>\n  new RelativeClock(clock, clock.now())\n\nexport const newPerformanceClock = (): Clock =>\n  clockRelativeTo(performance)\n\n/**\n * @deprecated will be removed in 2.0.0\n * Date.now is not monotonic, and performance.now is ubiquitous:\n * @see https://caniuse.com/#search=performance.now\n */\nexport const newDateClock = (): Clock =>\n  clockRelativeTo(Date)\n\nexport const newHRTimeClock = (): Clock =>\n  new HRTimeClock(process.hrtime, process.hrtime())\n\nexport const newPlatformClock = (): Clock => {\n  if (typeof performance !== 'undefined' && typeof performance.now === 'function') {\n    return newPerformanceClock()\n  } else if (typeof process !== 'undefined' && typeof process.hrtime === 'function') {\n    return newHRTimeClock()\n  }\n\n  return newDateClock()\n}\n", "import { curry2, curry3 } from '@most/prelude'\nimport { Scheduler, Time, Task, ScheduledTask } from '@most/types'\n\n/**\n * Read the current time from the provided Scheduler\n */\nexport const currentTime = (scheduler: Scheduler): Time =>\n  scheduler.currentTime()\n\n/**\n * Schedule a task to run as soon as possible, but\n * not in the current call stack\n */\nexport const asap = curry2((task: Task, scheduler: Scheduler): ScheduledTask =>\n  scheduler.scheduleTask(0, 0, -1, task))\n\n/**\n * Schedule a task to run after a millisecond delay\n */\nexport const delay = curry3((delay: Time, task: Task, scheduler: Scheduler): ScheduledTask =>\n  scheduler.scheduleTask(0, delay, -1, task))\n\n/**\n * Schedule a task to run periodically, with the\n * first run starting asap\n */\nexport const periodic = curry3((period: Time, task: Task, scheduler: Scheduler): ScheduledTask =>\n  scheduler.scheduleTask(0, 0, period, task))\n\n/**\n * Cancel a scheduledTask\n */\nexport const cancelTask = (scheduledTask: ScheduledTask): void =>\n  scheduledTask.dispose()\n\n/**\n * Cancel all ScheduledTasks for which a predicate is true\n * @deprecated Will be removed in 2.0.0\n */\nexport const cancelAllTasks = curry2((predicate: (task: ScheduledTask) => boolean, scheduler: Scheduler): void => {\n  console.warn(`DEPRECATED cancelAllTasks to be removed in 2.0.0`)\n  return scheduler.cancelAll(predicate)\n})\n", "import RelativeScheduler from './RelativeScheduler'\nimport { curry2 } from '@most/prelude'\nimport { Time, Scheduler } from '@most/types'\n\nexport const schedulerRelativeTo = curry2((offset: Time, scheduler: Scheduler): Scheduler =>\n  new RelativeScheduler(offset, scheduler))\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { curry2 } from '@most/prelude'\n\nimport Scheduler from './Scheduler'\nimport TimelineImpl from './Timeline'\nimport ClockTimer from './ClockTimer'\nimport { newPlatformClock } from './clock'\nimport { Clock, Timer, Timeline } from '@most/types'\n\nexport * from './clock'\nexport * from './schedule'\nexport * from './relative'\n\nexport const newScheduler = curry2((timer: Timer, timeline: Timeline): Scheduler => new Scheduler(timer, timeline))\n\nexport const newDefaultScheduler = (): Scheduler => new Scheduler(newDefaultTimer(), new TimelineImpl())\n\nexport const newDefaultTimer = (): Timer => new ClockTimer(newPlatformClock())\nexport const newClockTimer = (clock: Clock): Timer => new ClockTimer(clock)\n\nexport const newTimeline = (): Timeline => new TimelineImpl()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\nexport const dispose = (disposable: Disposable): void =>\n  disposable.dispose()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\nexport const disposeNone = (): Disposable => NONE\nconst NONE = new (class DisposeNone implements Disposable {\n  dispose(): void{}\n})()\n\nexport const isDisposeNone = (d: Disposable): boolean =>\n  d === NONE\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\n/**\n * Wrap an existing disposable (which may not already have been once()d)\n * so that it will only dispose its underlying resource at most once.\n */\nexport const disposeOnce = (disposable: Disposable): Disposable =>\n  new DisposeOnce(disposable)\n\nclass DisposeOnce implements Disposable {\n  private disposed = false;\n  private disposable?: Disposable\n\n  constructor(disposable: Disposable) {\n    this.disposable = disposable\n  }\n\n  dispose(): void {\n    if (!this.disposed) {\n      this.disposed = true\n      if (this.disposable) {\n        this.disposable.dispose()\n        this.disposable = undefined\n      }\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { disposeOnce } from './disposeOnce'\nimport { curry2 } from '@most/prelude'\nimport { Disposable } from '@most/types'\n\nexport interface DisposeWith {\n  (): DisposeWith\n  <R>(dispose: (resource: R) => void): (resource: R) => Disposable\n  <R>(dispose: (resource: R) => void, resource: R): Disposable\n}\n\n/**\n * Create a Disposable that will use the provided\n * dispose function to dispose the resource\n */\nexport const disposeWith: DisposeWith = curry2((dispose, resource) =>\n  disposeOnce(new DisposeWithImpl(dispose, resource)))\n\n/**\n * Disposable represents a resource that must be\n * disposed/released. It aggregates a function to dispose\n * the resource and a handle to a key/id/handle/reference\n * that identifies the resource\n */\nclass DisposeWithImpl<R> implements Disposable {\n  private _dispose: (resource: R) => void;\n  private _resource: R;\n\n  constructor(dispose: (resource: R) => void, resource: R) {\n    this._dispose = dispose\n    this._resource = resource\n  }\n\n  dispose(): void {\n    this._dispose(this._resource)\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\nimport { append, reduce, curry2, concat } from '@most/prelude'\nimport { disposeNone, isDisposeNone } from './disposeNone'\nimport { Disposable } from '@most/types'\n\n/**\n * Aggregate a list of disposables into a DisposeAll\n */\nexport const disposeAll = (ds: ArrayLike<Disposable>): Disposable => {\n  const merged = reduce(merge, [], ds)\n  return merged.length === 0 ? disposeNone() : new DisposeAll(merged)\n}\n\n/**\n * Convenience to aggregate 2 disposables\n */\nexport const disposeBoth = curry2((d1: Disposable, d2: Disposable): Disposable =>\n  disposeAll([d1, d2]))\n\nconst merge = (ds: Disposable[], d: Disposable): Disposable[] =>\n  isDisposeNone(d) ? ds\n    : d instanceof DisposeAll ? concat(ds, d.disposables)\n      : append(d, ds)\n\nclass DisposeAll implements Disposable {\n  readonly disposables: ArrayLike<Disposable>\n\n  constructor(disposables: ArrayLike<Disposable>) {\n    this.disposables = disposables\n  }\n\n  dispose(): void {\n    throwIfErrors(disposeCollectErrors(this.disposables))\n  }\n}\n\n/**\n * Dispose all, safely collecting errors into an array\n */\nconst disposeCollectErrors = (disposables: ArrayLike<Disposable>): Error[] =>\n  reduce(appendIfError, [], disposables)\n\n/**\n * Call dispose and if throws, append thrown error to errors\n */\nconst appendIfError = (errors: Error[], d: Disposable): Error[] => {\n  try {\n    d.dispose()\n  } catch (e) {\n    errors.push(e)\n  }\n  return errors\n}\n\n/**\n * Throw DisposeAllError if errors is non-empty\n * @throws\n */\nconst throwIfErrors = (errors: ArrayLike<Error>): void => {\n  if (errors.length > 0) {\n    throw new DisposeAllError(`${errors.length} errors`, errors)\n  }\n}\n\nexport class DisposeAllError implements Error {\n  readonly name: string = 'DisposeAllError'\n  readonly stack?: string;\n  readonly message: string;\n  readonly errors: ArrayLike<Error>;\n\n  constructor(message: string, errors: ArrayLike<Error>) {\n    this.message = message\n    this.errors = errors\n    Error.call(this, message)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, DisposeAllError)\n    }\n    this.stack = `${this.stack}${formatErrorStacks(this.errors)}`\n  }\n}\nDisposeAllError.prototype = Object.create(Error.prototype)\n\nconst formatErrorStacks = (errors: ArrayLike<Error>): string =>\n  reduce(formatErrorStack, '', errors)\n\nconst formatErrorStack = (s: string, e: Error, i: number): string =>\n  s + `\\n[${(i + 1)}] ${e.stack}`\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { curry3 } from '@most/prelude'\nimport { Disposable, Sink, Time } from '@most/types'\n\n// Try to dispose the disposable.  If it throws, send\n// the error to sink.error with the provided Time value\nexport const tryDispose = curry3((t: Time, disposable: Disposable, sink: Sink<unknown>): void => {\n  try {\n    disposable.dispose()\n  } catch (e) {\n    sink.error(t, e)\n  }\n})\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nexport default function fatalError(e: unknown): void {\n  setTimeout(rethrow, 0, e)\n}\n\nfunction rethrow(e: unknown): never {\n  throw e\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport fatal from '../fatalError'\nimport { Sink, Time, Task, Disposable } from '@most/types'\n\nexport type PropagateTaskRun<A> =\n  (time: number, value: A, sink: Sink<A>) => void\n\nexport const propagateTask = <A>(run: PropagateTaskRun<A>, value: A, sink: Sink<A>): PropagateTask => new PropagateRunEventTask(run, value, sink)\n\nexport const propagateEventTask = <A>(value: A, sink: Sink<A>): PropagateTask => new PropagateEventTask(value, sink)\n\nexport const propagateEndTask = (sink: Sink<unknown>): PropagateTask => new PropagateEndTask(sink)\n\nexport const propagateErrorTask = (value: Error, sink: Sink<Error>): PropagateTask => new PropagateErrorTask(value, sink)\n\nexport abstract class PropagateTask implements Task, Disposable {\n  active: boolean = true\n\n  constructor(protected readonly sink: Sink<unknown>) {}\n\n  protected abstract runIfActive(t: Time): void\n\n  dispose(): void {\n    this.active = false\n  }\n\n  run(t: Time): void {\n    if (!this.active) {\n      return\n    }\n    this.runIfActive(t)\n  }\n\n  error(t: Time, e: Error): void {\n    // TODO: Remove this check and just do this.sink.error(t, e)?\n    if (!this.active) {\n      return fatal(e)\n    }\n    this.sink.error(t, e)\n  }\n}\n\nclass PropagateRunEventTask<A> extends PropagateTask implements Task, Disposable {\n  constructor(private readonly runEvent: PropagateTaskRun<A>, private readonly value: A, sink: Sink<A>) {\n    super(sink)\n  }\n\n  protected runIfActive(t: Time): void {\n    this.runEvent(t, this.value, this.sink)\n  }\n}\n\nclass PropagateEventTask<A> extends PropagateTask implements Task, Disposable {\n  constructor(private readonly value: A, sink: Sink<A>) {\n    super(sink)\n  }\n\n  protected runIfActive(t: Time): void {\n    this.sink.event(t, this.value)\n  }\n}\n\nclass PropagateEndTask extends PropagateTask implements Task, Disposable {\n  protected runIfActive(t: Time): void {\n    this.sink.end(t)\n  }\n}\n\nclass PropagateErrorTask extends PropagateTask implements Task, Disposable {\n  constructor(private readonly value: Error, sink: Sink<never>) {\n    super(sink)\n  }\n\n  protected runIfActive(t: Time): void {\n    this.sink.error(t, this.value)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { propagateEndTask } from '../scheduler/PropagateTask'\nimport { asap } from '@most/scheduler'\nimport { Stream, Sink, Scheduler, Disposable } from '@most/types'\n\nexport const empty = (): Stream<never> => EMPTY\n\nexport const isCanonicalEmpty = (stream: Stream<unknown>): boolean =>\n  stream === EMPTY\n\nexport const containsCanonicalEmpty = <A>(streams: ReadonlyArray<Stream<A>>): boolean =>\n  streams.some(isCanonicalEmpty)\n\nclass Empty implements Stream<never> {\n  run(sink: Sink<never>, scheduler: Scheduler): Disposable {\n    return asap(propagateEndTask(sink), scheduler)\n  }\n}\n\nconst EMPTY = new Empty()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { disposeNone } from '@most/disposable'\nimport { Disposable, Stream } from '@most/types'\n\nexport const never = (): Stream<never> => NEVER\n\nclass Never implements Stream<never> {\n  run(): Disposable {\n    return disposeNone()\n  }\n}\n\nconst NEVER = new Never()\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { propagateTask } from '../scheduler/PropagateTask'\nimport { delay } from '@most/scheduler'\nimport { Time, Stream, Sink, Scheduler, Disposable } from '@most/types'\n\nexport const at = <A>(t: Time, x: A): Stream<A> => new At(t, x)\n\nclass At<A> implements Stream<A> {\n  private readonly time: Time;\n  private readonly value: A;\n\n  constructor(t: Time, x: A) {\n    this.time = t\n    this.value = x\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return delay(this.time, propagateTask(runAt, this.value, sink), scheduler)\n  }\n}\n\nfunction runAt<A>(t: Time, x: A, sink: Sink<A>): void {\n  sink.event(t, x)\n  sink.end(t)\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { at } from './at'\nimport { Stream } from '@most/types'\n\nexport const now = <A>(x: A): Stream<A> => at(0, x)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { propagateEventTask } from '../scheduler/PropagateTask'\nimport { periodic as schedulePeriodic } from '@most/scheduler'\nimport { Stream, Sink, Scheduler, Disposable } from '@most/types'\n\n/**\n * Create a stream of events that occur at a regular period\n * @param {Number} period periodicity of events\n * @returns {Stream} new stream of periodic events, the event value is undefined\n */\nexport const periodic = (period: number): Stream<void> =>\n  new Periodic(period)\n\nclass Periodic implements Stream<void> {\n  private readonly period: number;\n\n  constructor(period: number) {\n    this.period = period\n  }\n\n  run(sink: Sink<void>, scheduler: Scheduler): Disposable {\n    return schedulePeriodic(this.period, propagateEventTask(undefined, sink), scheduler)\n  }\n}\n", "import { Sink, Scheduler, Disposable, Stream } from '@most/types'\n\n/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nexport type RunStream<A> = (sink: Sink<A>, scheduler: Scheduler) => Disposable\n\nexport const newStream = <A>(run: RunStream<A>): Stream<A> => new StreamImpl(run)\n\nclass StreamImpl<A> {\n  readonly run: RunStream<A>;\n  constructor(run: RunStream<A>) {\n    this.run = run\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Disposable } from '@most/types'\n\nexport default class SettableDisposable implements Disposable {\n  private disposable?: Disposable;\n  private disposed: boolean;\n\n  constructor() {\n    this.disposable = undefined\n    this.disposed = false\n  }\n\n  setDisposable(disposable: Disposable): void {\n    if (this.disposable !== undefined) {\n      throw new Error('setDisposable called more than once')\n    }\n\n    this.disposable = disposable\n\n    if (this.disposed) {\n      disposable.dispose()\n    }\n  }\n\n  dispose(): void {\n    if (this.disposed) {\n      return\n    }\n\n    this.disposed = true\n\n    if (this.disposable !== undefined) {\n      this.disposable.dispose()\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { curry2 } from '@most/prelude'\nimport SettableDisposable from './disposable/SettableDisposable'\nimport { Stream, Scheduler, Time, Disposable, Sink } from '@most/types'\n\nexport interface RunEffects {\n  <A>(stream: Stream<A>, scheduler: Scheduler): Promise<void>\n  <A>(stream: Stream<A>): (scheduler: Scheduler) => Promise<void>\n}\n\nexport const runEffects: RunEffects = curry2((stream: Stream<unknown>, scheduler: Scheduler): Promise<void> =>\n  new Promise((resolve, reject) =>\n    runStream(stream, scheduler, resolve, reject)))\n\nfunction runStream <A>(stream: Stream<A>, scheduler: Scheduler, resolve: (a: A | undefined) => void, reject: (e: Error) => void): void {\n  const disposable = new SettableDisposable()\n  const observer = new RunEffectsSink(resolve, reject, disposable)\n\n  disposable.setDisposable(stream.run(observer, scheduler))\n}\n\nclass RunEffectsSink<A> implements Sink<A> {\n  private readonly _disposable: Disposable\n  private active: boolean;\n  private _error: (e: Error) => void\n  private _end: (x: A | undefined) => void\n\n  constructor(end: (x: A | undefined) => void, error: (e: Error) => void, disposable: Disposable) {\n    this._end = end\n    this._error = error\n    this._disposable = disposable\n    this.active = true\n  }\n\n  event(): void {}\n\n  end(): void {\n    if (!this.active) {\n      return\n    }\n    this.dispose(this._error, this._end, undefined)\n  }\n\n  error(_t: Time, e: Error): void {\n    this.dispose(this._error, this._error, e)\n  }\n\n  private dispose <X>(error: (e: Error) => void, end: (x: X) => void, x: X): void {\n    this.active = false\n    tryDispose(error, end, x, this._disposable)\n  }\n}\n\nfunction tryDispose <X>(error: (e: Error) => void, end: (x: X) => void, x: X, disposable: Disposable): void {\n  try {\n    disposable.dispose()\n  } catch (e) {\n    error(e)\n    return\n  }\n\n  end(x)\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\nimport { Sink, Scheduler, Stream, Disposable } from '@most/types'\n\n/**\n * Run a Stream, sending all its events to the provided Sink.\n */\nexport const run = <A>(sink: Sink<A>, scheduler: Scheduler, stream: Stream<A>): Disposable =>\n  stream.run(sink, scheduler)\n", "import { Sink, Time } from '@most/types'\n\nexport default class RelativeSink<A> implements Sink<A> {\n  readonly offset: number\n  readonly sink: Sink<A>\n\n  constructor(offset: number, sink: Sink<A>) {\n    this.sink = sink\n    this.offset = offset\n  }\n\n  event(t: Time, x: A): void {\n    this.sink.event(t + this.offset, x)\n  }\n\n  error(t: Time, e: Error): void {\n    this.sink.error(t + this.offset, e)\n  }\n\n  end(t: Time): void {\n    this.sink.end(t + this.offset)\n  }\n}\n", "import RelativeSink from '../sink/RelativeSink'\nimport { schedulerRelativeTo } from '@most/scheduler'\nimport { Time, Stream, Sink, Scheduler, Disposable } from '@most/types'\n\n/**\n * Create a stream with its own local clock\n * This transforms time from the provided scheduler's clock to a stream-local\n * clock (which starts at 0), and then *back* to the scheduler's clock before\n * propagating events to sink.  In other words, upstream sources will see local times,\n * and downstream sinks will see non-local (original) times.\n */\nexport const withLocalTime = <A>(origin: Time, stream: Stream<A>): Stream<A> =>\n  new WithLocalTime(origin, stream)\n\nclass WithLocalTime<A> implements Stream<A> {\n  private readonly origin: Time;\n  private readonly source: Stream<A>;\n\n  constructor(origin: Time, source: Stream<A>) {\n    this.origin = origin\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(relativeSink(this.origin, sink), schedulerRelativeTo(this.origin, scheduler))\n  }\n}\n\n/**\n * Accumulate offsets instead of nesting RelativeSinks, which can happen\n * with higher-order stream and combinators like continueWith when they're\n * applied recursively.\n */\nexport const relativeSink = <A>(origin: Time, sink: Sink<A>): Sink<A> =>\n  sink instanceof RelativeSink\n    ? new RelativeSink(origin + sink.offset, sink.sink)\n    : new RelativeSink(origin, sink)\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n/** @author Brian Cavalier */\nimport { Sink, Time } from '@most/types'\n\nexport default abstract class Pipe<A, B> implements Sink<A> {\n  protected readonly sink: Sink<B>\n\n  constructor(sink: Sink<B>) {\n    this.sink = sink\n  }\n\n  abstract event (t: Time, x: A): void\n\n  end(t: Time): void {\n    return this.sink.end(t)\n  }\n\n  error(t: Time, e: Error): void {\n    return this.sink.error(t, e)\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport interface SeedValue<S, V> { seed: S, value: V }\n\n/**\n * Generalized feedback loop. Call a stepper function for each event. The stepper\n * will be called with 2 params: the current seed and the an event value.  It must\n * return a new { seed, value } pair. The `seed` will be fed back into the next\n * invocation of stepper, and the `value` will be propagated as the event value.\n * @param stepper loop step function\n * @param seed initial seed value passed to first stepper call\n * @param stream event stream\n * @returns new stream whose values are the `value` field of the objects\n * returned by the stepper\n */\nexport const loop = <A, B, S>(stepper: (seed: S, a: A) => SeedValue<S, B>, seed: S, stream: Stream<A>): Stream<B> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new Loop(stepper, seed, stream)\n\nclass Loop<A, B, S> implements Stream<B> {\n  private readonly step: (seed: S, a: A) => SeedValue<S, B>\n  private readonly seed: S;\n  private readonly source: Stream<A>\n\n  constructor(stepper: (seed: S, a: A) => SeedValue<S, B>, seed: S, source: Stream<A>) {\n    this.step = stepper\n    this.seed = seed\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return this.source.run(new LoopSink(this.step, this.seed, sink), scheduler)\n  }\n}\n\nclass LoopSink<A, B, S> extends Pipe<A, B> implements Sink<A> {\n  private readonly step: (seed: S, a: A) => SeedValue<S, B>;\n  private seed: S;\n  constructor(stepper: (seed: S, a: A) => SeedValue<S, B>, seed: S, sink: Sink<B>) {\n    super(sink)\n    this.step = stepper\n    this.seed = seed\n  }\n\n  event(t: Time, x: A): void {\n    const result = this.step(this.seed, x)\n    this.seed = result.seed\n    this.sink.event(t, result.value)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { asap } from '@most/scheduler'\nimport { propagateEventTask } from '../scheduler/PropagateTask'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Create a stream containing successive reduce results of applying f to\n * the previous reduce result and the current stream item.\n * @param f reducer function\n * @param initial initial value\n * @param stream stream to scan\n * @returns new stream containing successive reduce results\n */\nexport const scan = <A, B>(f: (b: B, a: A) => B, initial: B, stream: Stream<A>): Stream<B> =>\n  new Scan(f, initial, stream)\n\nclass Scan<A, B> implements Stream<B> {\n  private readonly source: Stream<A>;\n  private readonly f: (b: B, a: A) => B;\n  private readonly value: B;\n\n  constructor(f: (b: B, a: A) => B, z: B, source: Stream<A>) {\n    this.source = source\n    this.f = f\n    this.value = z\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    const d1 = asap(propagateEventTask(this.value, sink), scheduler)\n    const d2 = this.source.run(new ScanSink(this.f, this.value, sink), scheduler)\n    return disposeBoth(d1, d2)\n  }\n}\n\nclass ScanSink<A, B> extends Pipe<A, B> implements Sink<A> {\n  private readonly f: (b: B, a: A) => B\n  private value: B;\n\n  constructor(f: (b: B, a: A) => B, z: B, sink: Sink<B>) {\n    super(sink)\n    this.f = f\n    this.value = z\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    this.value = f(this.value, x)\n    this.sink.event(t, this.value)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { run } from '../run'\nimport { withLocalTime } from './withLocalTime'\nimport { disposeOnce, tryDispose } from '@most/disposable'\nimport { Stream, Scheduler, Time, Disposable, Sink } from '@most/types'\n\nexport const continueWith = <A, B = A>(f: () => Stream<B>, stream: Stream<A>): Stream<A | B> =>\n  new ContinueWith(f, stream)\n\nclass ContinueWith<A, B> implements Stream<A | B> {\n  private readonly f: () => Stream<B>\n  private readonly source: Stream<A>\n\n  constructor(f: () => Stream<B>, source: Stream<A>) {\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<A | B>, scheduler: Scheduler): Disposable {\n    return new ContinueWithSink(this.f, this.source, sink, scheduler)\n  }\n}\n\nclass ContinueWithSink<A, B> extends Pipe<A, A | B> implements Sink<A>, Disposable {\n  private readonly f: () => Stream<B>;\n  private readonly scheduler: Scheduler;\n  private active: boolean;\n  private disposable: Disposable\n\n  constructor(f: () => Stream<B>, source: Stream<A>, sink: Sink<A | B>, scheduler: Scheduler) {\n    super(sink)\n    this.f = f\n    this.scheduler = scheduler\n    this.active = true\n    this.disposable = disposeOnce(source.run(this, scheduler))\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n    this.sink.event(t, x)\n  }\n\n  end(t: Time): void {\n    if (!this.active) {\n      return\n    }\n\n    tryDispose(t, this.disposable, this.sink)\n\n    this.startNext(t, this.sink)\n  }\n\n  private startNext(t: Time, sink: Sink<A | B>): void {\n    try {\n      this.disposable = this.continue(this.f, t, sink)\n    } catch (e) {\n      sink.error(t, e)\n    }\n  }\n\n  private continue(f: () => Stream<B>, t: Time, sink: Sink<A | B>): Disposable {\n    return run(sink, this.scheduler, withLocalTime(t, f()))\n  }\n\n  dispose(): void {\n    this.active = false\n    return this.disposable.dispose()\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport { now } from '../source/now'\nimport { continueWith } from './continueWith'\nimport { Stream } from '@most/types'\n\nexport const startWith = <A>(x: A, stream: Stream<A>): Stream<A> =>\n  continueWith(() => stream, now(x))\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport default class Filter<A> implements Stream<A> {\n  readonly p: (a: A) => boolean\n  readonly source: Stream<A>\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new FilterSink(this.p, sink), scheduler)\n  }\n\n  /**\n   * Create a filtered source, fusing adjacent filter.filter if possible\n   * @param {function(x:*):boolean} p filtering predicate\n   * @param {{run:function}} source source to filter\n   * @returns {Filter} filtered source\n   */\n  static create <A>(p: (a: A) => boolean, source: Stream<A>): Stream<A> {\n    if (isCanonicalEmpty(source)) {\n      return source\n    }\n\n    if (source instanceof Filter) {\n      return new Filter(and(source.p, p), source.source)\n    }\n\n    return new Filter(p, source)\n  }\n}\n\nclass FilterSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.p = p\n  }\n\n  event(t: Time, x: A): void {\n    const p = this.p\n    p(x) && this.sink.event(t, x)\n  }\n}\n\nconst and = <A>(p: (a: A) => boolean, q: (a: A) => boolean) => (x: A): boolean => p(x) && q(x)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport default class FilterMap<A, B> implements Stream<B> {\n  private readonly p: (a: A) => boolean;\n  private readonly f: (a: A) => B;\n  private readonly source: Stream<A>;\n\n  constructor(p: (a: A) => boolean, f: (a: A) => B, source: Stream<A>) {\n    this.p = p\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return this.source.run(new FilterMapSink(this.p, this.f, sink), scheduler)\n  }\n}\n\nclass FilterMapSink<A, B> extends Pipe<A, B> implements Sink<A> {\n  private readonly p: (a: A) => boolean;\n  private readonly f: (a: A) => B;\n\n  constructor(p: (a: A) => boolean, f: (a: A) => B, sink: Sink<B>) {\n    super(sink)\n    this.p = p\n    this.f = f\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    const p = this.p\n    p(x) && this.sink.event(t, f(x))\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport Filter from './Filter'\nimport FilterMap from './FilterMap'\nimport { compose } from '@most/prelude'\nimport { isCanonicalEmpty, empty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport default class Map<A, B> implements Stream<B> {\n  readonly f: (a: A) => B;\n  readonly source: Stream<A>;\n\n  constructor(f: (a: A) => B, source: Stream<A>) {\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return this.source.run(new MapSink(this.f, sink), scheduler)\n  }\n\n  /**\n   * Create a mapped source, fusing adjacent map.map, filter.map,\n   * and filter.map.map if possible\n   * @param {function(*):*} f mapping function\n   * @param {{run:function}} source source to map\n   * @returns {Map|FilterMap} mapped source, possibly fused\n   */\n  static create <A, B>(f: (a: A) => B, source: Stream<A>): Stream<B> {\n    if (isCanonicalEmpty(source)) {\n      return empty()\n    }\n\n    if (source instanceof Map) {\n      return new Map(compose(f, source.f), source.source)\n    }\n\n    if (source instanceof Filter) {\n      return new FilterMap(source.p, f, source.source)\n    }\n\n    return new Map(f, source)\n  }\n}\n\nclass MapSink<A, B> extends Pipe<A, B> implements Sink<A> {\n  private readonly f: (a: A) => B;\n\n  constructor(f: (a: A) => B, sink: Sink<B>) {\n    super(sink)\n    this.f = f\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    this.sink.event(t, f(x))\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Map from '../fusion/Map'\nimport Pipe from '../sink/Pipe'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Transform each value in the stream by applying f to each\n * @param f mapping function\n * @param stream stream to map\n * @returns stream containing items transformed by f\n */\nexport const map = <A, B>(f: (a: A) => B, stream: Stream<A>): Stream<B> =>\n  Map.create(f, stream)\n\n/**\n* Replace each value in the stream with x\n* @param x\n* @param stream\n* @returns stream containing items replaced with x\n*/\nexport const constant = <A, B>(x: B, stream: Stream<A>): Stream<B> =>\n  map(() => x, stream)\n\n/**\n* Perform a side effect for each item in the stream\n* @param f side effect to execute for each item. The return value will be discarded.\n* @param stream stream to tap\n* @returns new stream containing the same items as this stream\n*/\nexport const tap = <A>(f: (a: A) => unknown, stream: Stream<A>): Stream<A> =>\n  new Tap(f, stream)\n\nclass Tap<A> implements Stream<A> {\n  private readonly f: (a: A) => unknown;\n  private readonly source: Stream<A>;\n\n  constructor(f: (a: A) => unknown, source: Stream<A>) {\n    this.source = source\n    this.f = f\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new TapSink(this.f, sink), scheduler)\n  }\n}\n\nclass TapSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly f: (a: A) => unknown;\n\n  constructor(f: (a: A) => unknown, sink: Sink<A>) {\n    super(sink)\n    this.f = f\n  }\n\n  event(t: Time, x: A): void {\n    const f = this.f\n    f(x)\n    this.sink.event(t, x)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from './Pipe'\nimport { Time, Sink } from '@most/types'\n\nexport interface IndexedValue<A> {\n  readonly index: number\n  readonly value: A\n  readonly active: boolean\n}\n\nexport class IndexSink<A> extends Pipe<A, IndexedValue<A | undefined>> implements Sink<A> {\n  readonly index: number\n  active: boolean\n  value: A | undefined\n\n  constructor(i: number, sink: Sink<IndexedValue<A | undefined>>) {\n    super(sink)\n    this.index = i\n    this.active = true\n    this.value = undefined\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n    this.value = x\n    this.sink.event(t, this)\n  }\n\n  end(t: Time): void {\n    if (!this.active) {\n      return\n    }\n    this.active = false\n    this.sink.event(t, this)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\n/**\n * TODO: find a better way (without `any`)\n */\nexport default function invoke <F extends(...args: any[]) => any>(f: F, args: Parameters<F>): ReturnType<F> {\n  /* eslint complexity: [2,7] */\n  switch (args.length) {\n    case 0: return f()\n    case 1: return f(args[0])\n    case 2: return f(args[0], args[1])\n    case 3: return f(args[0], args[1], args[2])\n    case 4: return f(args[0], args[1], args[2], args[3])\n    case 5: return f(args[0], args[1], args[2], args[3], args[4])\n    default:\n      return f.apply(undefined, args)\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport { map } from './transform'\nimport { empty, containsCanonicalEmpty } from '../source/empty'\nimport Pipe from '../sink/Pipe'\nimport { IndexSink, IndexedValue } from '../sink/IndexSink'\nimport { disposeAll, tryDispose } from '@most/disposable'\nimport invoke from '../invoke'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\nimport { ToStreamsArray } from './variadic'\n\n/**\n * Combine latest events from two streams\n * @param f function to combine most recent events\n * @param stream1\n * @param stream2\n * @returns stream containing the result of applying f to the most recent\n *  event of each input stream, whenever a new event arrives on any stream.\n */\nexport const combine = <A, B, C>(f: (a: A, b: B) => C, stream1: Stream<A>, stream2: Stream<B>): Stream<C> =>\n  combineArray(f, [stream1, stream2])\n\n/**\n* Combine latest events from all input streams\n* @param f function to combine most recent events\n* @param streams most recent events\n* @returns stream containing the result of applying f to the most recent\n*  event of each input stream, whenever a new event arrives on any stream.\n*/\nexport const combineArray = <Args extends unknown[], R>(f: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R> =>\n  streams.length === 0 || containsCanonicalEmpty(streams) ? empty()\n    : streams.length === 1 ? map(f as any, streams[0])\n      : new Combine(f, streams)\n\nclass Combine<Args extends unknown[], B> implements Stream<B> {\n  private readonly f: (...args: Args) => B\n  private readonly sources: ToStreamsArray<Args>;\n\n  constructor(f: (...args: Args) => B, sources: ToStreamsArray<Args>) {\n    this.f = f\n    this.sources = sources\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    const l = this.sources.length\n    const disposables = new Array(l)\n    const sinks = new Array(l)\n\n    const mergeSink = new CombineSink(disposables, sinks.length, sink, this.f)\n\n    for (let indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink)\n      disposables[i] = this.sources[i].run(indexSink, scheduler)\n    }\n\n    return disposeAll(disposables)\n  }\n}\n\nclass CombineSink<A, Args extends A[], B> extends Pipe<IndexedValue<A>, B> implements Sink<IndexedValue<A>> {\n  private readonly disposables: Disposable[]\n  private readonly f: (...args: Args) => B\n  private awaiting: number\n  private readonly hasValue: boolean[]\n  private activeCount: number\n  private readonly values: Args\n\n  constructor(disposables: Disposable[], length: number, sink: Sink<B>, f: (...args: Args) => B) {\n    super(sink)\n    this.disposables = disposables\n    this.f = f\n\n    this.awaiting = length\n    this.values = new Array(length) as Args\n    this.hasValue = new Array(length).fill(false)\n    this.activeCount = length\n  }\n\n  event(t: Time, indexedValue: IndexedValue<A>): void {\n    if (!indexedValue.active) {\n      this.dispose(t, indexedValue.index)\n      return\n    }\n\n    const i = indexedValue.index\n    const awaiting = this.updateReady(i)\n\n    this.values[i] = indexedValue.value\n    if (awaiting === 0) {\n      this.sink.event(t, invoke(this.f, this.values))\n    }\n  }\n\n  private updateReady(index: number): number {\n    if (this.awaiting > 0) {\n      if (!this.hasValue[index]) {\n        this.hasValue[index] = true\n        this.awaiting -= 1\n      }\n    }\n    return this.awaiting\n  }\n\n  private dispose(t: Time, index: number): void {\n    tryDispose(t, this.disposables[index], this.sink)\n    if (--this.activeCount === 0) {\n      this.sink.end(t)\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { combine } from './combine'\nimport { apply } from '@most/prelude'\nimport { Stream } from '@most/types'\n\n/**\n * Assume fs is a stream containing functions, and apply the latest function\n * in fs to the latest value in xs.\n * fs:         --f---------g--------h------>\n * xs:         -a-------b-------c-------d-->\n * ap(fs, xs): --fa-----fb-gb---gc--hc--hd->\n * @param {Stream} fs stream of functions to apply to the latest x\n * @param {Stream} xs stream of values to which to apply all the latest f\n * @returns {Stream} stream containing all the applications of fs to xs\n */\nexport function ap<A, B>(fs: Stream<(a: A) => B>, xs: Stream<A>): Stream<B> {\n  return combine(apply, fs, xs)\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport { disposeAll, disposeNone, disposeOnce, tryDispose } from '@most/disposable'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { id as identity } from '@most/prelude'\nimport { schedulerRelativeTo } from '@most/scheduler'\nimport { Time, Disposable, Sink, Scheduler, Stream } from '@most/types'\n\nexport const mergeConcurrently = <A>(concurrency: number, stream: Stream<Stream<A>>): Stream<A> =>\n  mergeMapConcurrently(identity, concurrency, stream)\n\nexport const mergeMapConcurrently = <A, B>(f: (a: A) => Stream<B>, concurrency: number, stream: Stream<A>): Stream<B> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new MergeConcurrently(f, concurrency, stream)\n\nclass MergeConcurrently<A, B> implements Stream<B> {\n  private readonly concurrency: number;\n  private readonly f: (a: A) => Stream<B>\n  private readonly source: Stream<A>\n\n  constructor(f: (a: A) => Stream<B>, concurrency: number, source: Stream<A>) {\n    this.f = f\n    this.concurrency = concurrency\n    this.source = source\n  }\n\n  run(sink: Sink<B>, scheduler: Scheduler): Disposable {\n    return new Outer(this.f, this.concurrency, this.source, sink, scheduler)\n  }\n}\n\ninterface NonEmptyArray<A> extends Array<A> {\n  readonly [0]: A\n  shift(): A\n}\nconst isNonEmpty = <A>(array: A[]): array is NonEmptyArray<A> => array.length > 0\n\nclass Outer<A, B> implements Sink<A>, Disposable {\n  private readonly scheduler: Scheduler;\n  private readonly disposable: Disposable;\n  private active: boolean;\n  private readonly concurrency: number;\n  private readonly f: (a: A) => Stream<B>;\n  private readonly sink: Sink<B>;\n  private readonly current: Disposable[];\n  private readonly pending: A[];\n\n  constructor(f: (a: A) => Stream<B>, concurrency: number, source: Stream<A>, sink: Sink<B>, scheduler: Scheduler) {\n    this.f = f\n    this.concurrency = concurrency\n    this.sink = sink\n    this.scheduler = scheduler\n    this.pending = []\n    this.current = []\n    this.disposable = disposeOnce(source.run(this, scheduler))\n    this.active = true\n  }\n\n  event(t: Time, x: A): void {\n    this.addInner(t, x)\n  }\n\n  private addInner(t: Time, x: A): void {\n    if (this.current.length < this.concurrency) {\n      this.startInner(t, x)\n    } else {\n      this.pending.push(x)\n    }\n  }\n\n  private startInner(t: Time, x: A): void {\n    try {\n      this.initInner(t, x)\n    } catch (e) {\n      this.error(t, e)\n    }\n  }\n\n  private initInner(t: Time, x: A): void {\n    const innerSink = new Inner(t, this, this.sink)\n    innerSink.disposable = mapAndRun(this.f, t, x, innerSink, this.scheduler)\n    this.current.push(innerSink)\n  }\n\n  end(t: Time): void {\n    this.active = false\n    tryDispose(t, this.disposable, this.sink)\n    this.checkEnd(t)\n  }\n\n  error(t: Time, e: Error): void{\n    this.active = false\n    this.sink.error(t, e)\n  }\n\n  dispose(): void {\n    this.active = false\n    this.pending.length = 0\n    this.disposable.dispose()\n    disposeAll(this.current).dispose()\n  }\n\n  endInner(t: Time, inner: Disposable): void {\n    const i = this.current.indexOf(inner)\n    if (i >= 0) {\n      this.current.splice(i, 1)\n    }\n    tryDispose(t, inner, this)\n\n    const pending = this.pending\n    if (isNonEmpty(pending)) {\n      this.startInner(t, pending.shift())\n    } else {\n      this.checkEnd(t)\n    }\n  }\n\n  private checkEnd(t: Time): void {\n    if (!this.active && this.current.length === 0) {\n      this.sink.end(t)\n    }\n  }\n}\n\nconst mapAndRun = <A, B>(f: (a: A) => Stream<B>, t: Time, x: A, sink: Sink<B>, scheduler: Scheduler): Disposable =>\n  f(x).run(sink, schedulerRelativeTo(t, scheduler))\n\nclass Inner<A, B> implements Sink<B>, Disposable {\n  private readonly time: number;\n  private readonly outer: Outer<A, B>;\n  disposable: Disposable;\n  private readonly sink: Sink<B>;\n\n  constructor(time: Time, outer: Outer<A, B>, sink: Sink<B>) {\n    this.time = time\n    this.outer = outer\n    this.sink = sink\n    this.disposable = disposeNone()\n  }\n\n  event(t: Time, x: B): void {\n    this.sink.event(t + this.time, x)\n  }\n\n  end(t: Time): void {\n    this.outer.endInner(t + this.time, this)\n  }\n\n  error(t: Time, e: Error): void {\n    this.outer.error(t + this.time, e)\n  }\n\n  dispose(): void {\n    return this.disposable.dispose()\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { mergeConcurrently, mergeMapConcurrently } from './mergeConcurrently'\nimport { Stream } from '@most/types'\n\n/**\n * Map each value in the stream to a new stream, and merge it into the\n * returned outer stream. Event arrival times are preserved.\n * @param f chaining function, must return a Stream\n * @param stream\n * @returns new stream containing all events from each stream returned by f\n */\nexport const chain = <A, B>(f: (value: A) => Stream<B>, stream: Stream<A>): Stream<B> => mergeMapConcurrently(f, Infinity, stream)\n\n/**\n * Monadic join. Flatten a Stream<Stream<X>> to Stream<X> by merging inner\n * streams to the outer. Event arrival times are preserved.\n * @param stream stream of streams\n * @returns new stream containing all events of all inner streams\n */\nexport const join = <A>(stream: Stream<Stream<A>>): Stream<A> => mergeConcurrently(Infinity, stream)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { mergeMapConcurrently } from './mergeConcurrently'\nimport { Stream } from '@most/types'\n\n/**\n * Map each value in stream to a new stream, and concatenate them all\n * stream:              -a---b---cX\n * f(a):                 1-1-1-1X\n * f(b):                        -2-2-2-2X\n * f(c):                                -3-3-3-3X\n * stream.concatMap(f): -1-1-1-1-2-2-2-2-3-3-3-3X\n * @param f function to map each value to a stream\n * @param stream\n * @returns new stream containing all events from each stream returned by f\n */\nexport const concatMap = <A, B>(f: (a: A) => Stream<B>, stream: Stream<A>): Stream<B> =>\n  mergeMapConcurrently(f, 1, stream)\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { IndexSink, IndexedValue } from '../sink/IndexSink'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { disposeAll, tryDispose } from '@most/disposable'\nimport { reduce } from '@most/prelude'\nimport { Stream, Time, Disposable, Sink, Scheduler } from '@most/types'\n\n/**\n * @returns stream containing events from two streams in time order.\n * If two events are simultaneous they will be merged in arbitrary order.\n */\nexport function merge <A, B>(stream1: Stream<A>, stream2: Stream<B>): Stream<A | B> {\n  return mergeArray([stream1, stream2])\n}\n\n// TODO: use readonly Stream<any>[] once TS 3.4.x has been in the wild for \"enough\" time\ntype MergeArray<S extends ReadonlyArray<Stream<any>>> = Value<S[number]>\ntype Value<S> = S extends Stream<infer A> ? A : never\n\n/**\n * @param streams array of stream to merge\n * @returns stream containing events from all input observables\n * in time order.  If two events are simultaneous they will be merged in\n * arbitrary order.\n */\nexport const mergeArray = <S extends ReadonlyArray<Stream<any>>>(streams: S): Stream<MergeArray<S>> =>\n  mergeStreams(withoutCanonicalEmpty(streams))\n\n/**\n * This implements fusion/flattening for merge.  It will\n * fuse adjacent merge operations.  For example:\n * - a.merge(b).merge(c) effectively becomes merge(a, b, c)\n * - merge(a, merge(b, c)) effectively becomes merge(a, b, c)\n * It does this by concatenating the sources arrays of\n * any nested Merge sources, in effect \"flattening\" nested\n * merge operations into a single merge.\n * TODO: use {@link MergeArray}\n */\nconst mergeStreams = <A>(streams: Stream<A>[]): Stream<A> =>\n  streams.length === 0 ? empty()\n    : streams.length === 1 ? streams[0]\n      : new Merge(reduce<Stream<A>[], Stream<A>>(appendSources, [], streams))\n\nconst withoutCanonicalEmpty = <A>(streams: ReadonlyArray<Stream<A>>): Stream<A>[] =>\n  streams.filter(isNotCanonicalEmpty)\n\nconst isNotCanonicalEmpty = <A>(stream: Stream<A>): boolean =>\n  !isCanonicalEmpty(stream)\n\nconst appendSources = <A>(sources: Stream<A>[], stream: Stream<A>): Stream<A>[] =>\n  sources.concat(stream instanceof Merge ? stream.sources : stream)\n\nclass Merge<A> implements Stream<A> {\n  readonly sources: Stream<A>[];\n\n  constructor(sources: Stream<A>[]) {\n    this.sources = sources\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const l = this.sources.length\n    const disposables: Disposable[] = new Array(l)\n    const sinks: Sink<A>[] = new Array(l)\n\n    const mergeSink = new MergeSink(disposables, sinks, sink)\n\n    for (let indexSink, i = 0; i < l; ++i) {\n      indexSink = sinks[i] = new IndexSink(i, mergeSink)\n      disposables[i] = this.sources[i].run(indexSink, scheduler)\n    }\n\n    return disposeAll(disposables)\n  }\n}\n\nclass MergeSink<A> extends Pipe<IndexedValue<A>, A> implements Sink<IndexedValue<A>> {\n  private readonly disposables: Disposable[];\n  private activeCount: number;\n\n  constructor(disposables: Disposable[], sinks: Sink<unknown>[], sink: Sink<A>) {\n    super(sink)\n    this.disposables = disposables\n    this.activeCount = sinks.length\n  }\n\n  event(t: Time, indexValue: IndexedValue<A>): void {\n    if (!indexValue.active) {\n      this.dispose(t, indexValue.index)\n      return\n    }\n    this.sink.event(t, indexValue.value)\n  }\n\n  private dispose(t: Time, index: number): void {\n    tryDispose(t, this.disposables[index], this.sink)\n    if (--this.activeCount === 0) {\n      this.sink.end(t)\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\nexport const sample = <A, B>(values: Stream<A>, sampler: Stream<B>): Stream<A> =>\n  snapshot(x => x, values, sampler)\n\nexport const snapshot = <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>): Stream<C> =>\n  isCanonicalEmpty(sampler) || isCanonicalEmpty(values)\n    ? empty()\n    : new Snapshot(f, values, sampler)\n\nexport class Snapshot<A, B, C> implements Stream<C> {\n  private readonly f: (a: A, b: B) => C\n  private readonly values: Stream<A>\n  private readonly sampler: Stream<B>\n\n  constructor(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>) {\n    this.f = f\n    this.values = values\n    this.sampler = sampler\n  }\n\n  run(sink: Sink<C>, scheduler: Scheduler): Disposable {\n    const sampleSink = new SnapshotSink(this.f, sink)\n    const valuesDisposable = this.values.run(sampleSink.latest, scheduler)\n    const samplerDisposable = this.sampler.run(sampleSink, scheduler)\n\n    return disposeBoth(samplerDisposable, valuesDisposable)\n  }\n}\n\nexport class SnapshotSink<A, B, C> extends Pipe<B, C> implements Sink<B> {\n  private readonly f: (a: A, b: B) => C\n  readonly latest: LatestValueSink<A>;\n\n  constructor(f: (a: A, b: B) => C, sink: Sink<C>) {\n    super(sink)\n    this.f = f\n    this.latest = new LatestValueSink(this)\n  }\n\n  event(t: Time, x: B): void {\n    if (this.latest.hasValue) {\n      const f = this.f\n      // TODO: value should be boxed to avoid ! bang\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.sink.event(t, f(this.latest.value!, x))\n    }\n  }\n}\n\nexport class LatestValueSink<A> extends Pipe<A, A> implements Sink<A> {\n  hasValue: boolean;\n  value?: A;\n\n  constructor(sink: Sink<unknown>) {\n    super(sink)\n    this.hasValue = false\n  }\n\n  event(_t: Time, x: A): void {\n    this.value = x\n    this.hasValue = true\n  }\n\n  end(): void {}\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\n// A slice Bounds type that narrows min values via accumulation\n// and max values via Math.min.\n// type Bounds = { min: number, max: number }\n// Notes:\n// 0 <= min <= max\n// slice(min2, max2, slice(min1, max1, s)) ~ slice(min1 + min2, Math.min(max1, min1 + max2), s)\n// A bounds has a 1d coord system with origin 0, extending to Infinity.  Both min and max\n// are relative to the origin (0).  However, when merging bounds b1 and b2, we\n// *interpret* b2 as being relative to b1, hence adding min1 to *both* min2 and max2.\n// This essentially translates b2's coordinates back into origin coordinates\n// as bounds are merged.\n\nexport interface Bounds {\n  readonly min: number\n  readonly max: number\n}\n\n// Construct a constrained bounds\nexport const boundsFrom = (unsafeMin: number, unsafeMax: number): Bounds => {\n  const min = Math.max(0, unsafeMin)\n  const max = Math.max(min, unsafeMax)\n  return { min, max }\n}\n\n// Combine 2 bounds by narrowing min and max\nexport const mergeBounds = (b1: Bounds, b2: Bounds): Bounds =>\n  boundsFrom(b1.min + b2.min, Math.min(b1.max, b1.min + b2.max))\n\n// Nil bounds excludes all slice indices\nexport const isNilBounds = (b: Bounds): boolean =>\n  b.min >= b.max\n\n// Infinite bounds includes all slice indices\nexport const isInfiniteBounds = (b: Bounds): boolean =>\n  b.min <= 0 && b.max === Infinity\n", "import { empty, isCanonicalEmpty } from '../../source/empty'\nimport { boundsFrom, isNilBounds, isInfiniteBounds, mergeBounds, Bounds } from './bounds'\nimport Map from '../../fusion/Map'\nimport Pipe from '../../sink/Pipe'\nimport SettableDisposable from '../../disposable/SettableDisposable'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\n// TODO: split into smaller files\n\n/**\n * @param n\n * @param stream\n * @returns new stream containing only up to the first n items from stream\n */\nexport const take = <A>(n: number, stream: Stream<A>): Stream<A> =>\n  slice(0, n, stream)\n\n/**\n * @param n\n * @param stream\n * @returns new stream with the first n items removed\n */\nexport const skip = <A>(n: number, stream: Stream<A>): Stream<A> =>\n  slice(n, Infinity, stream)\n\n/**\n * Slice a stream by index. Negative start/end indexes are not supported\n * @param start\n * @param end\n * @param stream\n * @returns stream containing items where start <= index < end\n */\nexport const slice = <A>(start: number, end: number, stream: Stream<A>): Stream<A> =>\n  sliceBounds(boundsFrom(start, end), stream)\n\nconst sliceBounds = <A>(bounds: Bounds, stream: Stream<A>): Stream<A> =>\n  isSliceEmpty(bounds, stream) ? empty()\n    : stream instanceof Map ? commuteMapSlice(bounds, stream)\n      : stream instanceof Slice ? fuseSlice(bounds, stream)\n        : createSlice(bounds, stream)\n\nconst isSliceEmpty = <A>(bounds: Bounds, stream: Stream<A>): boolean =>\n  isCanonicalEmpty(stream) || isNilBounds(bounds)\n\nconst createSlice = <A>(bounds: Bounds, stream: Stream<A>): Stream<A> =>\n  isInfiniteBounds(bounds) ? stream : new Slice(bounds, stream)\n\nconst commuteMapSlice = <A, B>(bounds: Bounds, mapStream: Map<A, B>): Stream<B> =>\n  Map.create(mapStream.f, sliceBounds(bounds, mapStream.source))\n\nconst fuseSlice = <A>(bounds: Bounds, sliceStream: Slice<A>): Stream<A> =>\n  sliceBounds(mergeBounds(sliceStream.bounds, bounds), sliceStream.source)\n\nexport class Slice<A> implements Stream<A> {\n  readonly bounds: Bounds;\n  readonly source: Stream<A>;\n\n  constructor(bounds: Bounds, source: Stream<A>) {\n    this.source = source\n    this.bounds = bounds\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const disposable = new SettableDisposable()\n    const sliceSink = new SliceSink(this.bounds.min, this.bounds.max - this.bounds.min, sink, disposable)\n\n    disposable.setDisposable(this.source.run(sliceSink, scheduler))\n\n    return disposable\n  }\n}\n\nclass SliceSink<A> extends Pipe<A, A> implements Sink<A> {\n  private skip: number\n  private take: number\n  private readonly disposable: Disposable\n  constructor(skip: number, take: number, sink: Sink<A>, disposable: Disposable) {\n    super(sink)\n    this.skip = skip\n    this.take = take\n    this.disposable = disposable\n  }\n\n  event(t: Time, x: A): void {\n    /* eslint complexity: [1, 4] */\n    if (this.skip > 0) {\n      this.skip -= 1\n      return\n    }\n\n    if (this.take === 0) {\n      return\n    }\n\n    this.take -= 1\n    this.sink.event(t, x)\n    if (this.take === 0) {\n      this.disposable.dispose()\n      this.sink.end(t)\n    }\n  }\n}\n\nexport const takeWhile = <A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new TakeWhile(p, stream)\n\nclass TakeWhile<A> implements Stream<A> {\n  private readonly p: (a: A) => boolean;\n  private readonly source: Stream<A>;\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const disposable = new SettableDisposable()\n    const takeWhileSink = new TakeWhileSink(this.p, sink, disposable)\n\n    disposable.setDisposable(this.source.run(takeWhileSink, scheduler))\n\n    return disposable\n  }\n}\n\nclass TakeWhileSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean\n  private readonly disposable: Disposable\n  private active: boolean;\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>, disposable: Disposable) {\n    super(sink)\n    this.p = p\n    this.active = true\n    this.disposable = disposable\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n\n    const p = this.p\n    this.active = p(x)\n\n    if (this.active) {\n      this.sink.event(t, x)\n    } else {\n      this.disposable.dispose()\n      this.sink.end(t)\n    }\n  }\n}\n\nexport const skipWhile = <A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new SkipWhile(p, stream)\n\nclass SkipWhile<A> implements Stream<A> {\n  private readonly p: (a: A) => boolean\n  private readonly source: Stream<A>\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new SkipWhileSink(this.p, sink), scheduler)\n  }\n}\n\nclass SkipWhileSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean;\n  private skipping: boolean;\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.p = p\n    this.skipping = true\n  }\n\n  event(t: Time, x: A): void {\n    if (this.skipping) {\n      const p = this.p\n      this.skipping = p(x)\n      if (this.skipping) {\n        return\n      }\n    }\n\n    this.sink.event(t, x)\n  }\n}\n\nexport const skipAfter = <A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new SkipAfter(p, stream)\n\nclass SkipAfter<A> implements Stream<A> {\n  private readonly p: (a: A) => boolean\n  private readonly source: Stream<A>\n\n  constructor(p: (a: A) => boolean, source: Stream<A>) {\n    this.p = p\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new SkipAfterSink(this.p, sink), scheduler)\n  }\n}\n\nclass SkipAfterSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly p: (a: A) => boolean;\n  private skipping: boolean;\n\n  constructor(p: (a: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.p = p\n    this.skipping = false\n  }\n\n  event(t: Time, x: A): void {\n    if (this.skipping) {\n      return\n    }\n\n    const p = this.p\n    this.skipping = p(x)\n    this.sink.event(t, x)\n\n    if (this.skipping) {\n      this.sink.end(t)\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2017 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { take } from './slice'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\nexport const withItems = <A> (items: Array<A>, stream: Stream<unknown>): Stream<A> =>\n  zipItems(keepLeft, items, stream)\n\nexport const zipItems = <A, B, C> (f: (a: A, b: B) => C, items: ArrayLike<A>, stream: Stream<B>): Stream<C> =>\n  isCanonicalEmpty(stream) || items.length === 0\n    ? empty()\n    : new ZipItems(f, items, take(items.length, stream))\n\nconst keepLeft = <A>(a: A): A => a\n\nclass ZipItems<A, B, C> implements Stream<C> {\n  private readonly f: (a: A, b: B) => C\n  private readonly items: ArrayLike<A>\n  private readonly source: Stream<B>\n\n  constructor(f: (a: A, b: B) => C, items: ArrayLike<A>, source: Stream<B>) {\n    this.f = f\n    this.items = items\n    this.source = source\n  }\n\n  run(sink: Sink<C>, scheduler: Scheduler): Disposable {\n    return this.source.run(new ZipItemsSink(this.f, this.items, sink), scheduler)\n  }\n}\n\nclass ZipItemsSink<A, B, C> extends Pipe<B, C> implements Sink<B> {\n  private readonly f: (a: A, b: B) => C\n  private readonly items: ArrayLike<A>\n  private index: number;\n\n  constructor(f: (a: A, b: B) => C, items: ArrayLike<A>, sink: Sink<C>) {\n    super(sink)\n    this.f = f\n    this.items = items\n    this.index = 0\n  }\n\n  event(t: Time, b: B): void {\n    const f = this.f\n    this.sink.event(t, f(this.items[this.index], b))\n    this.index += 1\n  }\n}\n", "// Copied and modified from https://github.com/invertase/denque\n// MIT License\n\n// These constants were extracted directly from denque's shift()\n// It's not clear exactly why the authors chose these particular\n// values, but given denque's stated goals, it seems likely that\n// they were chosen for speed/memory reasons.\n\n// Max value of _head at which Queue is willing to shink\n// its internal array\nconst HEAD_MAX_SHRINK = 2\n\n// Min value of _tail at which Queue is willing to shink\n// its internal array\nconst TAIL_MIN_SHRINK = 10000\n\nexport default class Queue<A> {\n  private head: number;\n  private tail: number;\n  private capacityMask: number;\n  private list: Array<A | undefined>;\n\n  constructor() {\n    this.head = 0\n    this.tail = 0\n    this.capacityMask = 0x3\n    this.list = new Array(4)\n  }\n\n  push(x: A): number {\n    const tail = this.tail\n    this.list[tail] = x\n    this.tail = (tail + 1) & this.capacityMask\n    if (this.tail === this.head) {\n      this.growArray()\n    }\n\n    if (this.head < this.tail) {\n      return this.tail - this.head\n    } else {\n      return this.capacityMask + 1 - (this.head - this.tail)\n    }\n  }\n\n  shift(): A | undefined {\n    const head = this.head\n    if (head === this.tail) {\n      return undefined\n    }\n\n    const x = this.list[head]\n    this.list[head] = undefined\n    this.head = (head + 1) & this.capacityMask\n    if (head < HEAD_MAX_SHRINK &&\n      this.tail > TAIL_MIN_SHRINK &&\n      this.tail <= this.list.length >>> 2) {\n      this.shrinkArray()\n    }\n\n    return x\n  }\n\n  isEmpty(): boolean {\n    return this.head === this.tail\n  }\n\n  length(): number {\n    if (this.head === this.tail) {\n      return 0\n    } else if (this.head < this.tail) {\n      return this.tail - this.head\n    } else {\n      return this.capacityMask + 1 - (this.head - this.tail)\n    }\n  }\n\n  private growArray(): void {\n    if (this.head) {\n      // copy existing data, head to end, then beginning to tail.\n      this.list = this.copyArray()\n      this.head = 0\n    }\n\n    // head is at 0 and array is now full, safe to extend\n    this.tail = this.list.length\n\n    this.list.length *= 2\n    this.capacityMask = (this.capacityMask << 1) | 1\n  }\n\n  private shrinkArray(): void {\n    this.list.length >>>= 1\n    this.capacityMask >>>= 1\n  }\n\n  private copyArray(): Array<A | undefined> {\n    const newArray: Array<A | undefined> = []\n    const list = this.list\n    const len = list.length\n\n    let i\n    for (i = this.head; i < len; i++) {\n      newArray.push(list[i])\n    }\n    for (i = 0; i < this.tail; i++) {\n      newArray.push(list[i])\n    }\n\n    return newArray\n  }\n}\n", "/** @license MIT License (c) copyright 2010 original author or authors */\n\nimport { map } from './transform'\nimport { empty, containsCanonicalEmpty } from '../source/empty'\nimport Pipe from '../sink/Pipe'\nimport { IndexSink, IndexedValue } from '../sink/IndexSink'\nimport { disposeAll } from '@most/disposable'\nimport { map as mapArray } from '@most/prelude'\nimport invoke from '../invoke'\nimport Queue from '../Queue'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\nimport { ToStreamsArray } from './variadic'\n\ninterface NonEmptyQueue<A> extends Queue<A> {\n  shift(): A\n}\n\n/**\n * Combine two streams pairwise by index by applying f to values at corresponding\n * indices.  The returned stream ends when either of the input streams ends.\n * @param {function} f function to combine values\n * @returns {Stream} new stream with items at corresponding indices combined\n *  using f\n */\nexport function zip <A, B, R>(f: (a: A, b: B) => R, stream1: Stream<A>, stream2: Stream<B>): Stream<R> {\n  return zipArray(f, [stream1, stream2])\n}\n\n/**\n* Combine streams pairwise (or tuple-wise) by index by applying f to values\n* at corresponding indices.  The returned stream ends when any of the input\n* streams ends.\n* @param {function} f function to combine values\n* @param {[Stream]} streams streams to zip using f\n* @returns {Stream} new stream with items at corresponding indices combined\n*  using f\n*/\nexport const zipArray = <Args extends unknown[], R>(f: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R> =>\n  streams.length === 0 || containsCanonicalEmpty(streams) ? empty()\n    : streams.length === 1 ? map(f as any, streams[0])\n      : new Zip(f as any, streams)\n\nclass Zip<A, R> implements Stream<R> {\n  private readonly f: (...args: ReadonlyArray<A>) => R\n  private readonly sources: ArrayLike<Stream<A>>\n\n  constructor(f: (...args: ReadonlyArray<A>) => R, sources: ArrayLike<Stream<A>>) {\n    this.f = f\n    this.sources = sources\n  }\n\n  run(sink: Sink<R>, scheduler: Scheduler): Disposable {\n    const l = this.sources.length\n    const disposables = new Array(l)\n    const sinks = new Array(l)\n    const buffers = new Array(l)\n\n    const zipSink = new ZipSink(this.f, buffers, sinks, sink)\n\n    for (let indexSink, i = 0; i < l; ++i) {\n      buffers[i] = new Queue()\n      indexSink = sinks[i] = new IndexSink(i, zipSink)\n      disposables[i] = this.sources[i].run(indexSink, scheduler)\n    }\n\n    return disposeAll(disposables)\n  }\n}\n\nclass ZipSink<A, R> extends Pipe<IndexedValue<A>, R> implements Sink<IndexedValue<A>> {\n  private readonly f: (...args: ReadonlyArray<A>) => R\n  private readonly buffers: ArrayLike<Queue<A>>\n  private readonly sinks: ArrayLike<IndexSink<A>>\n\n  constructor(f: (...args: ReadonlyArray<A>) => R, buffers: ArrayLike<Queue<A>>, sinks: ArrayLike<IndexSink<A>>, sink: Sink<R>) {\n    super(sink)\n    this.f = f\n    this.sinks = sinks\n    this.buffers = buffers\n  }\n\n  event(t: Time, indexedValue: IndexedValue<A>): void {\n    /* eslint complexity: [1, 5] */\n    if (!indexedValue.active) {\n      this.dispose(t, indexedValue.index)\n      return\n    }\n\n    const buffers = this.buffers\n    const buffer = buffers[indexedValue.index]\n\n    buffer.push(indexedValue.value)\n\n    if (buffer.length() === 1) {\n      if (!ready(buffers)) {\n        return\n      }\n\n      emitZipped(this.f, t, buffers, this.sink)\n\n      if (ended(this.buffers, this.sinks)) {\n        this.sink.end(t)\n      }\n    }\n  }\n\n  private dispose(t: Time, index: number): void {\n    const buffer = this.buffers[index]\n    if (buffer.isEmpty()) {\n      this.sink.end(t)\n    }\n  }\n}\n\nconst emitZipped = <A, R>(f: (...args: A[]) => R, t: Time, buffers: ArrayLike<NonEmptyQueue<A>>, sink: Sink<R>): void =>\n  sink.event(t, invoke(f, mapArray(head, buffers)))\n\nconst head = <A>(buffer: NonEmptyQueue<A>): A => buffer.shift()\n\nfunction ended <A>(buffers: ArrayLike<Queue<unknown>>, sinks: ArrayLike<IndexSink<A>>): boolean {\n  for (let i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty() && !sinks[i].active) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction ready <A>(buffers: ArrayLike<Queue<A>>): buffers is ArrayLike<NonEmptyQueue<A>> {\n  for (let i = 0, l = buffers.length; i < l; ++i) {\n    if (buffers[i].isEmpty()) {\n      return false\n    }\n  }\n  return true\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { disposeBoth, tryDispose } from '@most/disposable'\nimport { schedulerRelativeTo, currentTime } from '@most/scheduler'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\n/**\n * Given a stream of streams, return a new stream that adopts the behavior\n * of the most recent inner stream.\n * @param stream of streams on which to switch\n * @returns switching stream\n */\nexport const switchLatest = <A>(stream: Stream<Stream<A>>): Stream<A> =>\n  isCanonicalEmpty(stream)\n    ? empty()\n    : new Switch(stream)\n\nclass Switch<A> implements Stream<A> {\n  private readonly source: Stream<Stream<A>>\n\n  constructor(source: Stream<Stream<A>>) {\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const switchSink = new SwitchSink(sink, scheduler)\n    return disposeBoth(switchSink, this.source.run(switchSink, scheduler))\n  }\n}\n\nclass SwitchSink<A> implements Sink<Stream<A>>, Disposable {\n  private readonly sink: Sink<A>\n  private readonly scheduler: Scheduler\n  private ended: boolean\n  private current: Segment<A> | null\n\n  constructor(sink: Sink<A>, scheduler: Scheduler) {\n    this.sink = sink\n    this.scheduler = scheduler\n    this.current = null\n    this.ended = false\n  }\n\n  event(t: Time, stream: Stream<A>): void {\n    this.disposeCurrent(t)\n    this.current = new Segment(stream, t, Infinity, this, this.sink, this.scheduler)\n  }\n\n  end(t: Time): void {\n    this.ended = true\n    this.checkEnd(t)\n  }\n\n  error(t: Time, e: Error): void {\n    this.ended = true\n    this.sink.error(t, e)\n  }\n\n  dispose(): void {\n    return this.disposeCurrent(currentTime(this.scheduler))\n  }\n\n  private disposeCurrent(t: Time): void {\n    if (this.current !== null) {\n      return this.current.dispose(t)\n    }\n  }\n\n  private disposeInner(t: Time, inner: Segment<A>): void {\n    inner.dispose(t)\n    if (inner === this.current) {\n      this.current = null\n    }\n  }\n\n  private checkEnd(t: Time): void {\n    if (this.ended && this.current === null) {\n      this.sink.end(t)\n    }\n  }\n\n  endInner(t: Time, inner: Segment<A>): void {\n    this.disposeInner(t, inner)\n    this.checkEnd(t)\n  }\n\n  errorInner(t: Time, e: Error, inner: Segment<A>): void {\n    this.disposeInner(t, inner)\n    this.sink.error(t, e)\n  }\n}\n\nclass Segment<A> implements Sink<A> {\n  private readonly min: Time\n  private readonly max: Time\n  private readonly outer: SwitchSink<A>\n  private readonly sink: Sink<A>\n  private readonly disposable: Disposable\n\n  constructor(source: Stream<A>, min: Time, max: Time, outer: SwitchSink<A>, sink: Sink<A>, scheduler: Scheduler) {\n    this.min = min\n    this.max = max\n    this.outer = outer\n    this.sink = sink\n    this.disposable = source.run(this, schedulerRelativeTo(min, scheduler))\n  }\n\n  event(t: Time, x: A): void {\n    const time = Math.max(0, t + this.min)\n    if (time < this.max) {\n      this.sink.event(time, x)\n    }\n  }\n\n  end(t: Time): void {\n    this.outer.endInner(t + this.min, this)\n  }\n\n  error(t: Time, e: Error): void {\n    this.outer.errorInner(t + this.min, e, this)\n  }\n\n  dispose(t: Time): void {\n    tryDispose(t, this.disposable, this.sink)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport Filter from '../fusion/Filter'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Retain only items matching a predicate\n * @param p filtering predicate called for each item\n * @param stream stream to filter\n * @returns stream containing only items for which predicate returns truthy\n */\nexport function filter<A, B extends A>(p: (a: A) => a is B, stream: Stream<A>): Stream<B>\nexport function filter<A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A>\nexport function filter<A>(p: (a: A) => boolean, stream: Stream<A>): Stream<A> {\n  return Filter.create(p, stream)\n}\n\n/**\n * Skip repeated events, using === to detect duplicates\n * @param stream stream from which to omit repeated events\n * @returns stream without repeated events\n */\nexport const skipRepeats = <A>(stream: Stream<A>): Stream<A> =>\n  skipRepeatsWith(same, stream)\n\n/**\n * Skip repeated events using the provided equals function to detect duplicates\n * @param equals optional function to compare items\n * @param stream stream from which to omit repeated events\n * @returns stream without repeated events\n */\nexport const skipRepeatsWith = <A>(equals: (a1: A, a2: A) => boolean, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new SkipRepeats(equals, stream)\n\nclass SkipRepeats<A> implements Stream<A> {\n  private readonly equals: (a1: A, a2: A) => boolean\n  private readonly source: Stream<A>\n  constructor(equals: (a1: A, a2: A) => boolean, source: Stream<A>) {\n    this.equals = equals\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new SkipRepeatsSink(this.equals, sink), scheduler)\n  }\n}\n\nclass SkipRepeatsSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly equals: (a1: A, a2: A) => boolean\n  private value?: A;\n  private init: boolean;\n  constructor(equals: (a1: A, a2: A) => boolean, sink: Sink<A>) {\n    super(sink)\n    this.equals = equals\n    this.value = undefined\n    this.init = true\n  }\n\n  event(t: Time, x: A): void {\n    if (this.init) {\n      this.init = false\n      this.value = x\n      this.sink.event(t, x)\n      // TODO: value should be boxed to avoid ! bang\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    } else if (!this.equals(this.value!, x)) {\n      this.value = x\n      this.sink.event(t, x)\n    }\n  }\n}\n\nfunction same <A>(a: A, b: A): boolean {\n  return a === b\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { join } from './chain'\nimport SettableDisposable from '../disposable/SettableDisposable'\nimport { Stream, Scheduler, Sink, Disposable, Time } from '@most/types'\n\nexport const until = <A>(signal: Stream<unknown>, stream: Stream<A>): Stream<A> =>\n  new Until(signal, stream)\n\nexport const since = <A>(signal: Stream<unknown>, stream: Stream<A>): Stream<A> =>\n  new Since(signal, stream)\n\nexport const during = <A>(timeWindow: Stream<Stream<unknown>>, stream: Stream<A>): Stream<A> =>\n  until(join(timeWindow), since(timeWindow, stream))\n\nclass Until<A> implements Stream<A> {\n  private readonly maxSignal: Stream<unknown>\n  private readonly source: Stream<A>\n\n  constructor(maxSignal: Stream<unknown>, source: Stream<A>) {\n    this.maxSignal = maxSignal\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const disposable = new SettableDisposable()\n\n    const d1 = this.source.run(sink, scheduler)\n    const d2 = this.maxSignal.run(new UntilSink(sink, disposable), scheduler)\n    disposable.setDisposable(disposeBoth(d1, d2))\n\n    return disposable\n  }\n}\n\nclass Since<A> implements Stream<A> {\n  private readonly minSignal: Stream<Stream<unknown>>\n  private readonly source: Stream<A>\n\n  constructor(minSignal: Stream<Stream<unknown>>, source: Stream<A>) {\n    this.minSignal = minSignal\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const min = new LowerBoundSink(this.minSignal, sink, scheduler)\n    const d = this.source.run(new SinceSink(min, sink), scheduler)\n\n    return disposeBoth(min, d)\n  }\n}\n\nclass SinceSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly min: LowerBoundSink<A>\n\n  constructor(min: LowerBoundSink<A>, sink: Sink<A>) {\n    super(sink)\n    this.min = min\n  }\n\n  event(t: Time, x: A): void {\n    if (this.min.allow) {\n      this.sink.event(t, x)\n    }\n  }\n}\n\nclass LowerBoundSink<A> extends Pipe<A, A> implements Sink<A>, Disposable {\n  allow: boolean\n  private disposable: Disposable\n\n  constructor(signal: Stream<unknown>, sink: Sink<A>, scheduler: Scheduler) {\n    super(sink)\n    this.allow = false\n    this.disposable = signal.run(this, scheduler)\n  }\n\n  event(): void {\n    this.allow = true\n    this.dispose()\n  }\n\n  end(): void {}\n\n  dispose(): void {\n    this.disposable.dispose()\n  }\n}\n\nclass UntilSink<A> extends Pipe<A, A> implements Sink<A> {\n  private readonly disposable: Disposable\n\n  constructor(sink: Sink<A>, disposable: Disposable) {\n    super(sink)\n    this.disposable = disposable\n  }\n\n  event(t: Time): void {\n    this.disposable.dispose()\n    this.sink.end(t)\n  }\n\n  end(): void {}\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport Pipe from '../sink/Pipe'\nimport { disposeBoth } from '@most/disposable'\nimport { cancelTask, delay as scheduleDelay } from '@most/scheduler'\nimport { propagateEndTask, propagateEventTask } from '../scheduler/PropagateTask'\nimport { Stream, Sink, Scheduler, Disposable, ScheduledTask, Time } from '@most/types'\n\n/**\n * @param delayTime milliseconds to delay each item\n * @param stream\n * @returns new stream containing the same items, but delayed by ms\n */\nexport const delay = <A>(delayTime: number, stream: Stream<A>): Stream<A> =>\n  delayTime <= 0 ? stream : new Delay(delayTime, stream)\n\nclass Delay<A> implements Stream<A> {\n  private readonly dt: number\n  private readonly source: Stream<A>\n\n  constructor(dt: number, source: Stream<A>) {\n    this.dt = dt\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const delaySink = new DelaySink(this.dt, sink, scheduler)\n    return disposeBoth(delaySink, this.source.run(delaySink, scheduler))\n  }\n}\n\nclass DelaySink<A> extends Pipe<A, A> implements Sink<A>, Disposable {\n  private readonly dt: number;\n  private readonly scheduler: Scheduler;\n  private readonly tasks: ScheduledTask[];\n  constructor(dt: number, sink: Sink<A>, scheduler: Scheduler) {\n    super(sink)\n    this.dt = dt\n    this.scheduler = scheduler\n    this.tasks = []\n  }\n\n  dispose(): void {\n    this.tasks.forEach(cancelTask)\n  }\n\n  event(_t: Time, x: A): void {\n    this.tasks.push(scheduleDelay(this.dt, propagateEventTask(x, this.sink), this.scheduler))\n  }\n\n  end(): void {\n    this.tasks.push(scheduleDelay(this.dt, propagateEndTask(this.sink), this.scheduler))\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2017 original author or authors */\n\nimport Pipe from '../sink/Pipe'\nimport Map from '../fusion/Map'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { delay } from '@most/scheduler'\nimport { Stream, Time, Sink, Scheduler, Disposable, ScheduledTask, Task } from '@most/types'\n\n/**\n * Limit the rate of events by suppressing events that occur too often\n * @param period time to suppress events\n * @param stream\n */\nexport const throttle = <A>(period: number, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : stream instanceof Map ? commuteMapThrottle(period, stream)\n      : stream instanceof Throttle ? fuseThrottle(period, stream)\n        : new Throttle(period, stream)\n\nconst commuteMapThrottle = <A, B>(period: number, mapStream: Map<A, B>): Stream<B> =>\n  Map.create(mapStream.f, throttle(period, mapStream.source))\n\nconst fuseThrottle = <A>(period: number, throttleStream: Throttle<A>): Stream<A> =>\n  new Throttle(Math.max(period, throttleStream.period), throttleStream.source)\n\nexport class Throttle<A> implements Stream<A> {\n  readonly period: number;\n  readonly source: Stream<A>;\n\n  constructor(period: number, source: Stream<A>) {\n    this.period = period\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new ThrottleSink(this.period, sink), scheduler)\n  }\n}\n\nclass ThrottleSink<A> extends Pipe<A, A> implements Sink<A> {\n  private time: Time\n  private readonly period: number;\n\n  constructor(period: number, sink: Sink<A>) {\n    super(sink)\n    this.time = 0\n    this.period = period\n  }\n\n  event(t: Time, x: A): void {\n    if (t >= this.time) {\n      this.time = t + this.period\n      this.sink.event(t, x)\n    }\n  }\n}\n/**\n * Wait for a burst of events to subside and emit only the last event in the burst\n * @param period events occuring more frequently than this will be suppressed\n * @param stream stream to debounce\n * @returns new debounced stream\n */\nexport const debounce = <A>(period: number, stream: Stream<A>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new Debounce(period, stream)\n\nclass Debounce<A> implements Stream<A> {\n  private readonly dt: number;\n  private readonly source: Stream<A>\n\n  constructor(dt: number, source: Stream<A>) {\n    this.dt = dt\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return new DebounceSink(this.dt, this.source, sink, scheduler)\n  }\n}\n\nclass DebounceSink<A> implements Sink<A>, Disposable {\n  private readonly dt: number;\n  private readonly sink: Sink<A>;\n  private readonly scheduler: Scheduler\n  private value: A | undefined;\n  private timer: ScheduledTask | null\n  private disposable: Disposable\n\n  constructor(dt: number, source: Stream<A>, sink: Sink<A>, scheduler: Scheduler) {\n    this.dt = dt\n    this.sink = sink\n    this.scheduler = scheduler\n    this.timer = null\n\n    this.disposable = source.run(this, scheduler)\n  }\n\n  event(_t: Time, x: A): void {\n    this.clearTimer()\n    this.value = x\n    this.timer = delay(this.dt, new DebounceTask(this, x), this.scheduler)\n  }\n\n  handleEventFromTask(t: Time, x: A): void {\n    this.clearTimer()\n    this.sink.event(t, x)\n  }\n\n  end(t: Time): void {\n    if (this.clearTimer()) {\n      // TODO: value should be boxed to avoid ! bang\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.sink.event(t, this.value!)\n      this.value = undefined\n    }\n    this.sink.end(t)\n  }\n\n  error(t: Time, x: Error): void {\n    this.clearTimer()\n    this.sink.error(t, x)\n  }\n\n  dispose(): void {\n    this.clearTimer()\n    this.disposable.dispose()\n  }\n\n  private clearTimer(): boolean {\n    if (this.timer === null) {\n      return false\n    }\n    this.timer.dispose()\n    this.timer = null\n    return true\n  }\n}\n\nclass DebounceTask<A> implements Task {\n  private readonly sink: DebounceSink<A>;\n  private readonly value: A;\n\n  constructor(sink: DebounceSink<A>, value: A) {\n    this.sink = sink\n    this.value = value\n  }\n\n  run(t: Time): void {\n    this.sink.handleEventFromTask(t, this.value)\n  }\n\n  error(t: Time, e: Error): void {\n    this.sink.error(t, e)\n  }\n\n  dispose(): void {}\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport fatal from '../fatalError'\nimport { now } from '../source/now'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { currentTime } from '@most/scheduler'\nimport { Stream, Sink, Scheduler, Time, Disposable } from '@most/types'\n\n/**\n * Turn a Stream<Promise<T>> into Stream<T> by awaiting each promise.\n * Event order is preserved. The stream will fail if any promise rejects.\n */\nexport const awaitPromises = <A>(stream: Stream<Promise<A>>): Stream<A> =>\n  isCanonicalEmpty(stream) ? empty() : new Await(stream)\n\n/**\n * Create a stream containing only the promise's fulfillment\n * value at the time it fulfills.\n * @param promise\n * @return stream containing promise's fulfillment value.\n *  If the promise rejects, the stream will error\n */\nexport const fromPromise = <A>(promise: Promise<A>): Stream<A> => awaitPromises(now(promise))\n\nclass Await<A> implements Stream<A> {\n  private readonly source: Stream<Promise<A>>\n\n  constructor(source: Stream<Promise<A>>) {\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(new AwaitSink(sink, scheduler), scheduler)\n  }\n}\n\nclass AwaitSink<A> implements Sink<Promise<A>> {\n  private readonly sink: Sink<A>;\n  private readonly scheduler: Scheduler;\n  private queue: Promise<unknown>;\n\n  constructor(sink: Sink<A>, scheduler: Scheduler) {\n    this.sink = sink\n    this.scheduler = scheduler\n    this.queue = Promise.resolve()\n  }\n\n  event(_t: Time, promise: Promise<A>): void {\n    this.queue = this.queue.then(() => this.handlePromise(promise))\n      .catch(this.errorBound)\n  }\n\n  end(): void {\n    this.queue = this.queue.then(this.endBound)\n      .catch(this.errorBound)\n  }\n\n  error(_t: Time, e: Error): void {\n    // Don't resolve error values, propagate directly\n    this.queue = this.queue.then(() => this.errorBound(e))\n      .catch(fatal)\n  }\n\n  private handlePromise(promise: Promise<A>): Promise<void> {\n    return promise.then(this.eventBound)\n  }\n\n  // Pre-create closures, to avoid creating them per event\n  private eventBound = (x: A): void => this.sink.event(currentTime(this.scheduler), x)\n  private endBound = (): void => this.sink.end(currentTime(this.scheduler))\n  private errorBound = (e: Error): void => this.sink.error(currentTime(this.scheduler), e)\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\nimport { Sink, Time } from '@most/types'\n\nexport default class SafeSink<A> implements Sink<A> {\n  private readonly sink: Sink<A>\n  private active: boolean;\n\n  constructor(sink: Sink<A>) {\n    this.sink = sink\n    this.active = true\n  }\n\n  event(t: Time, x: A): void {\n    if (!this.active) {\n      return\n    }\n    this.sink.event(t, x)\n  }\n\n  end(t: Time): void{\n    if (!this.active) {\n      return\n    }\n    this.disable()\n    this.sink.end(t)\n  }\n\n  error(t: Time, e: Error): void{\n    this.disable()\n    this.sink.error(t, e)\n  }\n\n  disable(): Sink<A> {\n    this.active = false\n    return this.sink\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport { Time, Sink } from '@most/types'\n\nexport function tryEvent <A>(t: Time, x: A, sink: Sink<A>): void {\n  try {\n    sink.event(t, x)\n  } catch (e) {\n    sink.error(t, e)\n  }\n}\n\nexport function tryEnd(t: Time, sink: Sink<unknown>): void {\n  try {\n    sink.end(t)\n  } catch (e) {\n    sink.error(t, e)\n  }\n}\n", "/** @license MIT License (c) copyright 2010-2016 original author or authors */\n/** @author Brian Cavalier */\n/** @author John Hann */\n\nimport SafeSink from '../sink/SafeSink'\nimport { tryDispose } from '@most/disposable'\nimport { asap } from '@most/scheduler'\nimport { tryEvent, tryEnd } from '../source/tryEvent'\nimport { empty, isCanonicalEmpty } from '../source/empty'\nimport { propagateErrorTask } from '../scheduler/PropagateTask'\nimport { run } from '../run'\nimport { withLocalTime } from './withLocalTime'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\n\n/**\n * If stream encounters an error, recover and continue with items from stream\n * returned by f.\n * @param f which returns a new stream\n * @param stream\n * @returns new stream which will recover from an error by calling f\n */\nexport const recoverWith = <A, E extends Error, B = A>(f: (error: E) => Stream<B>, stream: Stream<A>): Stream<A | B> =>\n  isCanonicalEmpty(stream) ? empty()\n    : new RecoverWith(f, stream)\n\n/**\n * Create a stream containing only an error\n * @param e error value, preferably an Error or Error subtype\n * @returns new stream containing only an error\n */\nexport const throwError = (e: Error): Stream<never> =>\n  new ErrorStream(e)\n\nclass ErrorStream implements Stream<never> {\n  private readonly value: Error;\n\n  constructor(e: Error) {\n    this.value = e\n  }\n\n  run(sink: Sink<never>, scheduler: Scheduler): Disposable {\n    return asap(propagateErrorTask(this.value, sink), scheduler)\n  }\n}\n\nclass RecoverWith<A, E extends Error, B> implements Stream<A | B> {\n  private readonly f: (error: E) => Stream<B>;\n  private readonly source: Stream<A>;\n\n  constructor(f: (error: E) => Stream<B>, source: Stream<A>) {\n    this.f = f\n    this.source = source\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return new RecoverWithSink(this.f, this.source, sink, scheduler)\n  }\n}\n\nclass RecoverWithSink<A, E extends Error, B> implements Sink<A>, Disposable {\n  private readonly f: (error: E) => Stream<B>\n  private readonly sink: SafeSink<A>\n  private readonly scheduler: Scheduler\n  private disposable: Disposable\n\n  constructor(f: (error: E) => Stream<B>, source: Stream<A>, sink: Sink<A | B>, scheduler: Scheduler) {\n    this.f = f\n    this.sink = new SafeSink(sink)\n    this.scheduler = scheduler\n    this.disposable = source.run(this, scheduler)\n  }\n\n  event(t: Time, x: A): void {\n    tryEvent(t, x, this.sink)\n  }\n\n  end(t: Time): void {\n    tryEnd(t, this.sink)\n  }\n\n  error(t: Time, e: E): void {\n    const nextSink = this.sink.disable()\n\n    tryDispose(t, this.disposable, this.sink)\n\n    this._startNext(t, e, nextSink)\n  }\n\n  private _startNext(t: Time, x: E, sink: Sink<A>): void {\n    try {\n      this.disposable = this._continue(this.f, t, x, sink)\n    } catch (e) {\n      sink.error(t, e)\n    }\n  }\n\n  private _continue(f: (error: E) => Stream<B>, t: Time, x: E, sink: Sink<A | B>): Disposable {\n    return run(sink, this.scheduler, withLocalTime(t, f(x)))\n  }\n\n  dispose(): void {\n    return this.disposable.dispose()\n  }\n}\n", "import { append, findIndex, remove } from '@most/prelude'\nimport { disposeNone, disposeOnce } from '@most/disposable'\nimport { tryEnd, tryEvent } from '../source/tryEvent'\nimport { isCanonicalEmpty } from '../source/empty'\nimport { Stream, Scheduler, Sink, Disposable, Time } from '@most/types'\n\nexport const multicast = <A>(stream: Stream<A>): Stream<A> =>\n  stream instanceof Multicast || isCanonicalEmpty(stream)\n    ? stream\n    : new Multicast(stream)\n\nclass Multicast<A> implements Stream<A> {\n  private readonly source: Stream<A>;\n  constructor(source: Stream<A>) {\n    this.source = new MulticastSource(source)\n  }\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    return this.source.run(sink, scheduler)\n  }\n}\n\nexport class MulticastSource<A> implements Stream<A>, Disposable {\n  private readonly source: Stream<A>;\n  private sinks: Sink<A>[];\n  private disposable: Disposable;\n\n  constructor(source: Stream<A>) {\n    this.source = source\n    this.sinks = []\n    this.disposable = disposeNone()\n  }\n\n  run(sink: Sink<A>, scheduler: Scheduler): Disposable {\n    const n = this.add(sink)\n    if (n === 1) {\n      this.disposable = this.source.run(this, scheduler)\n    }\n    return disposeOnce(new MulticastDisposable(this, sink))\n  }\n\n  dispose(): void {\n    const disposable = this.disposable\n    this.disposable = disposeNone()\n    return disposable.dispose()\n  }\n\n  add(sink: Sink<A>): number {\n    this.sinks = append(sink, this.sinks)\n    return this.sinks.length\n  }\n\n  remove(sink: Sink<A>): number {\n    const i = findIndex(sink, this.sinks)\n    // istanbul ignore next\n    if (i >= 0) {\n      this.sinks = remove(i, this.sinks)\n    }\n\n    return this.sinks.length\n  }\n\n  event(time: Time, value: A): void {\n    const s = this.sinks\n    if (s.length === 1) {\n      return s[0].event(time, value)\n    }\n    for (let i = 0; i < s.length; ++i) {\n      tryEvent(time, value, s[i])\n    }\n  }\n\n  end(time: Time): void {\n    const s = this.sinks\n    for (let i = 0; i < s.length; ++i) {\n      tryEnd(time, s[i])\n    }\n  }\n\n  error(time: Time, err: Error): void {\n    const s = this.sinks\n    for (let i = 0; i < s.length; ++i) {\n      s[i].error(time, err)\n    }\n  }\n}\n\nexport class MulticastDisposable<A> implements Disposable {\n  private readonly source: MulticastSource<A>\n  private readonly sink: Sink<A>\n\n  constructor(source: MulticastSource<A>, sink: Sink<A>) {\n    this.source = source\n    this.sink = sink\n  }\n\n  dispose(): void {\n    if (this.source.remove(this.sink) === 0) {\n      this.source.dispose()\n    }\n  }\n}\n", "/** @license MIT License (c) copyright 2016 original author or authors */\n/* eslint-disable import/first */\nimport { curry2, curry3, Curried2 } from '@most/prelude'\n\nexport { empty } from './source/empty'\nexport { never } from './source/never'\nexport { now } from './source/now'\nexport { at } from './source/at'\n\nexport { periodic } from './source/periodic'\n\nexport { newStream } from './source/newStream'\n\n// -----------------------------------------------------------------------\n// Observing\n\nexport { runEffects } from './runEffects'\nimport { run as _run } from './run'\n\ninterface Run {\n  <A> (sink: Sink<A>, scheduler: Scheduler, s: Stream<A>): Disposable\n  <A> (sink: Sink<A>, scheduler: Scheduler): (s: Stream<A>) => Disposable\n  <A> (sink: Sink<A>): Curried2<Scheduler, Stream<A>, Disposable>\n}\nexport const run: Run = curry3(_run)\n\n// -------------------------------------------------------\n\nimport { withLocalTime as _withLocalTime } from './combinator/withLocalTime'\n\ninterface WithLocalTime {\n  <A>(origin: Time, s: Stream<A>): Stream<A>\n  <A>(origin: Time): (s: Stream<A>) => Stream<A>\n}\nexport const withLocalTime: WithLocalTime = curry2(_withLocalTime)\n\n// -------------------------------------------------------\n\nimport { loop as _loop, SeedValue } from './combinator/loop'\n\ninterface Loop {\n  <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>, seed: S, s: Stream<A>): Stream<B>\n  <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>, seed: S): (s: Stream<A>) => Stream<B>\n  <A, B, S>(f: (seed: S, a: A) => SeedValue<S, B>): Curried2<S, Stream<A>, Stream<B>>\n}\nexport const loop: Loop = curry3(_loop)\n\n// -------------------------------------------------------\n\nimport { scan as _scan } from './combinator/scan'\n\ninterface Scan {\n  <A, B>(f: (b: B, a: A) => B, b: B, s: Stream<A>): Stream<B>\n  <A, B>(f: (b: B, a: A) => B, b: B): (s: Stream<A>) => Stream<B>\n  <A, B>(f: (b: B, a: A) => B): Curried2<B, Stream<A>, Stream<B>>\n}\nexport const scan: Scan = curry3(_scan)\n\n// -----------------------------------------------------------------------\n// Extending\n\nimport { startWith as _startWith } from './combinator/startWith'\n\ninterface StartWith {\n  <A>(value: A, stream: Stream<A>): Stream<A>\n  <A>(value: A): (stream: Stream<A>) => Stream<A>\n}\nexport const startWith: StartWith = curry2(_startWith)\n\n// -----------------------------------------------------------------------\n// Transforming\n\nimport { map as _map, constant as _constant, tap as _tap } from './combinator/transform'\nimport { ap as _ap } from './combinator/applicative'\n\ninterface Map {\n  <A, B>(f: (a: A) => B, s: Stream<A>): Stream<B>\n  <A, B>(f: (a: A) => B): (s: Stream<A>) => Stream<B>\n}\nexport const map: Map = curry2(_map)\ninterface Constant {\n  <A, B>(b: B, s: Stream<A>): Stream<B>\n  <A, B>(b: B): (s: Stream<A>) => Stream<B>\n}\nexport const constant: Constant = curry2(_constant)\ninterface Tap {\n  <A>(f: (a: A) => any, s: Stream<A>): Stream<A>\n  <A>(f: (a: A) => any): (s: Stream<A>) => Stream<A>\n}\nexport const tap: Tap = curry2(_tap)\ninterface Ap {\n  <A, B>(streamofFunctions: Stream<(a: A) => B>, streamOfValues: Stream<A>): Stream<B>\n  <A, B>(streamofFunctions: Stream<(a: A) => B>): (streamOfValues: Stream<A>) => Stream<B>\n}\nexport const ap: Ap = curry2(_ap)\n\n// -----------------------------------------------------------------------\n// FlatMapping\n\nimport { chain as _chain, join } from './combinator/chain'\ninterface Chain {\n  <A, B>(f: (value: A) => Stream<B>, stream: Stream<A>): Stream<B>\n  <A, B>(f: (value: A) => Stream<B>): (stream: Stream<A>) => Stream<B>\n}\nexport const chain: Chain = curry2(_chain)\nexport { join }\n\nimport { continueWith as _continueWith } from './combinator/continueWith'\ninterface ContinueWith {\n  <A, B = A>(f: () => Stream<B>, s: Stream<A>): Stream<A | B>\n  <A, B = A>(f: () => Stream<B>): (s: Stream<A>) => Stream<A | B>\n}\nexport const continueWith: ContinueWith = curry2(_continueWith)\n\nimport { concatMap as _concatMap } from './combinator/concatMap'\ninterface ConcatMap {\n  <A, B>(f: (a: A) => Stream<B>, stream: Stream<A>): Stream<B>\n  <A, B>(f: (a: A) => Stream<B>): (stream: Stream<A>) => Stream<B>\n}\nexport const concatMap: ConcatMap = curry2(_concatMap)\n\n// -----------------------------------------------------------------------\n// Concurrent merging\n\nimport { mergeConcurrently as _mergeConcurrently, mergeMapConcurrently as _mergeMapConcurrently } from './combinator/mergeConcurrently'\n\ninterface MergeConcurrently {\n  <A>(concurrency: number, s: Stream<Stream<A>>): Stream<A>\n  <A>(concurrency: number): (s: Stream<Stream<A>>) => Stream<A>\n}\nexport const mergeConcurrently: MergeConcurrently = curry2<number, Stream<Stream<unknown>>, Stream<unknown>>(_mergeConcurrently)\ninterface MergeMapConcurrently {\n  <A, B>(f: (a: A) => Stream<B>, concurrency: number, s: Stream<A>): Stream<B>\n  <A, B>(f: (a: A) => Stream<B>, concurrency: number): (s: Stream<A>) => Stream<B>\n  <A, B>(f: (a: A) => Stream<B>): Curried2<number, Stream<A>, Stream<B>>\n}\nexport const mergeMapConcurrently: MergeMapConcurrently = curry3(_mergeMapConcurrently)\n\n// -----------------------------------------------------------------------\n// Merging\n\nimport { merge as _merge, mergeArray } from './combinator/merge'\n\ninterface Merge {\n  <A, B>(s1: Stream<A>, s2: Stream<B>): Stream<A | B>\n  <A, B>(s1: Stream<A>): (s2: Stream<B>) => Stream<A | B>\n}\nexport const merge: Merge = curry2(_merge)\nexport { mergeArray }\n\n// -----------------------------------------------------------------------\n// Combining\n\nimport { combine as _combine, combineArray as _combineArray } from './combinator/combine'\n\ninterface Combine {\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>, b: Stream<B>): Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>): (b: Stream<B>) => Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R): Curried2<Stream<A>, Stream<B>, Stream<R>>\n}\nexport const combine: Combine = curry3(_combine)\ninterface CombineArray {\n  <Args extends unknown[], R>(fn: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R>\n  <Args extends unknown[], R>(fn: (...args: Args) => R): (streams: ToStreamsArray<Args>) => Stream<R>\n}\nexport const combineArray: CombineArray = curry2(_combineArray as any) as any\n\n// -----------------------------------------------------------------------\n// Sampling\n\nimport { sample as _sample, snapshot as _snapshot } from './combinator/snapshot'\n\ninterface Sample {\n  <A, B>(values: Stream<A>, sampler: Stream<B>): Stream<A>\n  <A, B>(values: Stream<A>): (sampler: Stream<B>) => Stream<A>\n}\nexport const sample: Sample = curry2(_sample)\ninterface Snapshot {\n  <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>, sampler: Stream<B>): Stream<C>\n  <A, B, C>(f: (a: A, b: B) => C, values: Stream<A>): (sampler: Stream<B>) => Stream<C>\n  <A, B, C>(f: (a: A, b: B) => C): Curried2<Stream<A>, Stream<B>, Stream<C>>\n}\nexport const snapshot: Snapshot = curry3(_snapshot)\n\n// -----------------------------------------------------------------------\n// Zipping\n\nimport { zipItems as _zipItems, withItems as _withItems } from './combinator/zipItems'\ninterface ZipItems {\n  <A, B, C> (f: (a: A, b: B) => C, a: Array<A>, s: Stream<B>): Stream<C>\n  <A, B, C> (f: (a: A, b: B) => C, a: Array<A>): (s: Stream<B>) => Stream<C>\n  <A, B, C> (f: (a: A, b: B) => C): Curried2<Array<A>, Stream<B>, Stream<C>>\n}\nexport const zipItems: ZipItems = curry3(_zipItems)\ninterface WithItems {\n  <A>(a: Array<A>, s: Stream<unknown>): Stream<A>\n  <A>(a: Array<A>): (s: Stream<unknown>) => Stream<A>\n}\nexport const withItems: WithItems = curry2(_withItems)\n\nimport { zip as _zip, zipArray as _zipArray } from './combinator/zip'\ninterface Zip {\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>, b: Stream<B>): Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R, a: Stream<A>): (b: Stream<B>) => Stream<R>\n  <A, B, R>(fn: (a: A, b: B) => R): Curried2<Stream<A>, Stream<B>, Stream<R>>\n}\nexport const zip: Zip = curry3(_zip)\ninterface ZipArray {\n  <Args extends unknown[], R>(fn: (...args: Args) => R, streams: ToStreamsArray<Args>): Stream<R>\n  <Args extends unknown[], R>(fn: (...args: Args) => R): (streams: ToStreamsArray<Args>) => Stream<R>\n}\nexport const zipArray: ZipArray = curry2(_zipArray as any) as any\n\n// -----------------------------------------------------------------------\n// Switching\n\nexport { switchLatest } from './combinator/switch'\n\n// -----------------------------------------------------------------------\n// Filtering\n\nimport { filter as _filter, skipRepeats, skipRepeatsWith as _skipRepeatsWith } from './combinator/filter'\n\ninterface Filter {\n  <A, B extends A>(p: (a: A) => a is B, s: Stream<A>): Stream<B>\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A, B extends A>(p: (a: A) => a is B): (s: Stream<A>) => Stream<B>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const filter: Filter = curry2(_filter)\nexport { skipRepeats }\ninterface ShipRepeatsWith {\n  <A>(eq: (a1: A, a2: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(eq: (a1: A, a2: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const skipRepeatsWith: ShipRepeatsWith = curry2(_skipRepeatsWith)\n\n// -----------------------------------------------------------------------\n// Slicing\n\nimport { take as _take, skip as _skip, slice as _slice, takeWhile as _takeWhile, skipWhile as _skipWhile, skipAfter as _skipAfter } from './combinator/slice'\n\ninterface Take {\n  <A>(n: number, s: Stream<A>): Stream<A>\n  <A>(n: number): (s: Stream<A>) => Stream<A>\n}\nexport const take: Take = curry2(_take)\ninterface Skip {\n  <A>(n: number, s: Stream<A>): Stream<A>\n  <A>(n: number): (s: Stream<A>) => Stream<A>\n}\nexport const skip: Skip = curry2(_skip)\ninterface Slice {\n  <A>(start: number, end: number, s: Stream<A>): Stream<A>\n  <A>(start: number, end: number): (s: Stream<A>) => Stream<A>\n  <A>(start: number): Curried2<number, Stream<A>, Stream<A>>\n}\nexport const slice: Slice = curry3(_slice)\ninterface TakeWhile {\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const takeWhile: TakeWhile = curry2(_takeWhile)\ninterface SkipWhile {\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const skipWhile: SkipWhile = curry2(_skipWhile)\ninterface SkipAfter {\n  <A>(p: (a: A) => boolean, s: Stream<A>): Stream<A>\n  <A>(p: (a: A) => boolean): (s: Stream<A>) => Stream<A>\n}\nexport const skipAfter: SkipAfter = curry2(_skipAfter)\n\n// -----------------------------------------------------------------------\n// Time slicing\n\nimport { until as _until, since as _since, during as _during } from './combinator/timeslice'\n\ninterface Until {\n  <A>(signal: Stream<any>, s: Stream<A>): Stream<A>\n  <A>(signal: Stream<any>): (s: Stream<A>) => Stream<A>\n}\nexport const until: Until = curry2(_until)\ninterface Since {\n  <A>(signal: Stream<any>, s: Stream<A>): Stream<A>\n  <A>(signal: Stream<any>): (s: Stream<A>) => Stream<A>\n}\nexport const since: Since = curry2(_since)\ninterface During {\n  <A>(timeWindow: Stream<Stream<any>>, s: Stream<A>): Stream<A>\n  <A>(timeWindow: Stream<Stream<any>>): (s: Stream<A>) => Stream<A>\n}\nexport const during: During = curry2(_during)\n\n// -----------------------------------------------------------------------\n// Delaying\n\nimport { delay as _delay } from './combinator/delay'\n\ninterface Delay {\n  <A>(dt: number, s: Stream<A>): Stream<A>\n  <A>(dt: number): (s: Stream<A>) => Stream<A>\n}\nexport const delay: Delay = curry2(_delay)\n\n// -----------------------------------------------------------------------\n// Rate limiting\n\nimport { throttle as _throttle, debounce as _debounce } from './combinator/limit'\n\ninterface Throttle {\n  <A>(period: number, s: Stream<A>): Stream<A>\n  <A>(period: number): (s: Stream<A>) => Stream<A>\n}\nexport const throttle: Throttle = curry2(_throttle)\ninterface Debounce {\n  <A>(period: number, s: Stream<A>): Stream<A>\n  <A>(period: number): (s: Stream<A>) => Stream<A>\n}\nexport const debounce: Debounce = curry2(_debounce)\n\n// -----------------------------------------------------------------------\n// Awaiting Promises\n\nexport { fromPromise, awaitPromises } from './combinator/promises'\n\n// -----------------------------------------------------------------------\n// Error handling\n\nimport { recoverWith as _recoverWith, throwError } from './combinator/errors'\n\ninterface RecoverWith {\n  <A, E extends Error, B = A>(p: (error: E) => Stream<B>, s: Stream<A>): Stream<A | B>\n  <A, E extends Error, B = A>(p: (error: E) => Stream<B>): (s: Stream<A>) => Stream<A | B>\n}\nexport const recoverWith: RecoverWith = curry2(_recoverWith)\nexport { throwError }\n\n// -----------------------------------------------------------------------\n// Multicasting\n\nexport { multicast, MulticastSource } from './combinator/multicast'\n\n// ----------------------------------------------------------------------\nimport {\n  propagateTask as _propagateTask,\n  propagateEventTask as _propagateEventTask,\n  propagateErrorTask as _propagateErrorTask,\n  propagateEndTask,\n  PropagateTaskRun,\n  PropagateTask as PropagateTaskResult\n} from './scheduler/PropagateTask'\nimport { Stream, Sink, Scheduler, Disposable, Time } from '@most/types'\nimport { ToStreamsArray } from './combinator/variadic'\n\ninterface PropagateTask {\n  <A>(run: PropagateTaskRun<A>, value: A, sink: Sink<A>): PropagateTaskResult\n  <A>(run: PropagateTaskRun<A>, value: A): (sink: Sink<A>) => PropagateTaskResult\n  <A>(run: PropagateTaskRun<A>): Curried2<A, Sink<A>, PropagateTaskResult>\n}\nexport const propagateTask: PropagateTask = curry3(_propagateTask)\ninterface PropagateEventTask {\n  <T>(value: T, sink: Sink<T>): PropagateTaskResult\n  <T>(value: T): (sink: Sink<T>) => PropagateTaskResult\n}\nexport const propagateEventTask: PropagateEventTask = curry2(_propagateEventTask)\nexport const propagateErrorTask: Curried2<Error, Sink<unknown>, PropagateTaskResult> = curry2(_propagateErrorTask)\nexport { propagateEndTask }\n"],
  "mappings": "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",
  "names": ["b", "c", "ScheduledTaskImpl", "RelativeScheduler", "delay", "SchedulerImpl", "TimelineImpl", "at", "runTask", "ClockTimer", "Asap", "RelativeClock", "HRTimeClock", "Scheduler", "DisposeOnce", "DisposeWithImpl", "DisposeAll", "DisposeAllError", "run", "PropagateTask", "fatal", "PropagateRunEventTask", "PropagateEventTask", "PropagateEndTask", "PropagateErrorTask", "Empty", "Never", "At", "delay", "periodic", "Periodic", "schedulePeriodic", "StreamImpl", "SettableDisposable", "RunEffectsSink", "tryDispose", "RelativeSink", "WithLocalTime", "Pipe", "Loop", "LoopSink", "Scan", "ScanSink", "ContinueWith", "ContinueWithSink", "Filter", "FilterSink", "FilterMap", "FilterMapSink", "Map", "MapSink", "map", "Tap", "TapSink", "IndexSink", "Combine", "CombineSink", "identity", "MergeConcurrently", "Outer", "Inner", "merge", "Merge", "MergeSink", "Snapshot", "SnapshotSink", "LatestValueSink", "Slice", "SliceSink", "skip", "take", "TakeWhile", "TakeWhileSink", "SkipWhile", "SkipWhileSink", "SkipAfter", "SkipAfterSink", "ZipItems", "ZipItemsSink", "Queue", "head", "Zip", "ZipSink", "mapArray", "Switch", "SwitchSink", "Segment", "SkipRepeats", "SkipRepeatsSink", "Until", "Since", "SinceSink", "LowerBoundSink", "UntilSink", "Delay", "DelaySink", "scheduleDelay", "Throttle", "ThrottleSink", "Debounce", "DebounceSink", "DebounceTask", "Await", "AwaitSink", "SafeSink", "ErrorStream", "RecoverWith", "RecoverWithSink", "Multicast", "MulticastSource", "MulticastDisposable", "_run", "withLocalTime", "_withLocalTime", "loop", "_loop", "scan", "_scan", "startWith", "_startWith", "_map", "constant", "_constant", "tap", "_tap", "ap", "_ap", "chain", "_chain", "continueWith", "_continueWith", "concatMap", "_concatMap", "mergeConcurrently", "_mergeConcurrently", "mergeMapConcurrently", "_mergeMapConcurrently", "_merge", "combine", "_combine", "combineArray", "_combineArray", "sample", "_sample", "snapshot", "_snapshot", "zipItems", "_zipItems", "withItems", "_withItems", "zip", "_zip", "zipArray", "_zipArray", "filter", "_filter", "skipRepeatsWith", "_skipRepeatsWith", "_take", "_skip", "slice", "_slice", "takeWhile", "_takeWhile", "skipWhile", "_skipWhile", "skipAfter", "_skipAfter", "until", "_until", "since", "_since", "during", "_during", "_delay", "throttle", "_throttle", "debounce", "_debounce", "recoverWith", "_recoverWith", "propagateTask", "_propagateTask", "propagateEventTask", "_propagateEventTask", "propagateErrorTask", "_propagateErrorTask"]
}
