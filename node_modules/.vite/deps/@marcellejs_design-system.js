import {
  flip
} from "./chunk-3ROV3IZY.js";
import {
  writable
} from "./chunk-RAXL67E4.js";
import {
  blur,
  slide
} from "./chunk-PDA3SY24.js";
import "./chunk-M6MB33T7.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_flush_callback,
  add_location,
  add_render_callback,
  add_transform,
  append_dev,
  append_styles,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  component_subscribe,
  createEventDispatcher,
  create_animation,
  create_bidirectional_transition,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  fix_and_outro_and_destroy_block,
  fix_position,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  get_store_value,
  globals,
  group_outros,
  init,
  insert_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  prop_dev,
  run_all,
  safe_not_equal,
  select_option,
  select_value,
  setContext,
  set_custom_element_data,
  set_data_dev,
  set_style,
  space,
  src_url_equal,
  subscribe,
  svg_element,
  text,
  toggle_class,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-NLMIYH64.js";
import {
  formatDistanceToNow
} from "./chunk-Q2KGIWCH.js";
import {
  __publicField
} from "./chunk-MB5FDF5C.js";

// node_modules/@marcellejs/design-system/dist/index.js
import "/Users/user/Documents/Developing/marcelle-tutorial/node_modules/@marcellejs/design-system/dist/styles.css";

// node_modules/@marcellejs/design-system/dist/Button.svelte
var file = "node_modules/@marcellejs/design-system/dist/Button.svelte";
function add_css(target) {
  append_styles(target, "svelte-babmty", "button.svelte-babmty{cursor:pointer;border-radius:0.25rem;padding-left:1rem;padding-right:1rem;padding-top:0.5rem;padding-bottom:0.5rem;font-size:0.75rem;line-height:1rem;font-weight:600;outline:2px solid transparent;outline-offset:2px;transition:all 0.15s ease\n}button.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(224 242 254 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(2 132 199 / var(--tw-text-opacity))\n}button.svelte-babmty:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}button.svelte-babmty:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}button.size-small.svelte-babmty{padding-left:0.5rem;padding-right:0.5rem;padding-top:0.25rem;padding-bottom:0.25rem\n}button.size-large.svelte-babmty{padding-left:1.5rem;padding-right:1.5rem;padding-top:0.75rem;padding-bottom:0.75rem\n}button.outline.svelte-babmty{border-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(107 114 128 / var(--tw-text-opacity));transition:all 0.15s ease\n}button.outline.svelte-babmty:hover{--tw-border-opacity:1;border-color:rgb(14 165 233 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(240 249 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(14 165 233 / var(--tw-text-opacity))\n}button.filled.svelte-babmty{border-width:0px;--tw-bg-opacity:1;background-color:rgb(14 165 233 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))\n}button.filled.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(56 189 248 / var(--tw-bg-opacity))\n}button.light.svelte-babmty{border-width:0px;--tw-bg-opacity:1;background-color:rgb(224 242 254 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(2 132 199 / var(--tw-text-opacity))\n}button.light.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(186 230 253 / var(--tw-bg-opacity))\n}button.success.svelte-babmty{--tw-border-opacity:1;border-color:rgb(16 185 129 / var(--tw-border-opacity));--tw-text-opacity:1;color:rgb(16 185 129 / var(--tw-text-opacity))\n}button.success.svelte-babmty:hover{--tw-border-opacity:1;border-color:rgb(16 185 129 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(236 253 245 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(16 185 129 / var(--tw-text-opacity))\n}button.success.svelte-babmty:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(52 211 153 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}button.success.svelte-babmty:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}button.success.filled.svelte-babmty{--tw-bg-opacity:1;background-color:rgb(16 185 129 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))\n}button.success.filled.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(52 211 153 / var(--tw-bg-opacity))\n}button.success.light.svelte-babmty{--tw-bg-opacity:1;background-color:rgb(209 250 229 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(5 150 105 / var(--tw-text-opacity))\n}button.success.light.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(167 243 208 / var(--tw-bg-opacity))\n}button.warning.svelte-babmty{--tw-border-opacity:1;border-color:rgb(245 158 11 / var(--tw-border-opacity));--tw-text-opacity:1;color:rgb(245 158 11 / var(--tw-text-opacity))\n}button.warning.svelte-babmty:hover{--tw-border-opacity:1;border-color:rgb(245 158 11 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 251 235 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(245 158 11 / var(--tw-text-opacity))\n}button.warning.svelte-babmty:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(251 191 36 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}button.warning.svelte-babmty:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}button.warning.filled.svelte-babmty{--tw-bg-opacity:1;background-color:rgb(245 158 11 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))\n}button.warning.filled.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(251 191 36 / var(--tw-bg-opacity))\n}button.warning.light.svelte-babmty{--tw-bg-opacity:1;background-color:rgb(254 243 199 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(217 119 6 / var(--tw-text-opacity))\n}button.warning.light.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(253 230 138 / var(--tw-bg-opacity))\n}button.danger.svelte-babmty{--tw-border-opacity:1;border-color:rgb(244 63 94 / var(--tw-border-opacity));--tw-text-opacity:1;color:rgb(244 63 94 / var(--tw-text-opacity))\n}button.danger.svelte-babmty:hover{--tw-border-opacity:1;border-color:rgb(244 63 94 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 241 242 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(244 63 94 / var(--tw-text-opacity))\n}button.danger.svelte-babmty:focus{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(251 113 133 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}button.danger.svelte-babmty:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}button.danger.filled.svelte-babmty{--tw-bg-opacity:1;background-color:rgb(244 63 94 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(255 255 255 / var(--tw-text-opacity))\n}button.danger.filled.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(251 113 133 / var(--tw-bg-opacity))\n}button.danger.light.svelte-babmty{--tw-bg-opacity:1;background-color:rgb(255 228 230 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(225 29 72 / var(--tw-text-opacity))\n}button.danger.light.svelte-babmty:hover{--tw-bg-opacity:1;background-color:rgb(254 205 211 / var(--tw-bg-opacity))\n}button.svelte-babmty:disabled,button[disabled].svelte-babmty,button:hover[disabled].svelte-babmty{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}button.filled.svelte-babmty:disabled,button.filled[disabled].svelte-babmty,button.filled:hover[disabled].svelte-babmty{--tw-bg-opacity:1;background-color:rgb(209 213 219 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(249 250 251 / var(--tw-text-opacity))\n}button.light.svelte-babmty:disabled,button.light[disabled].svelte-babmty,button.light:hover[disabled].svelte-babmty{--tw-bg-opacity:1;background-color:rgb(229 231 235 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(156 163 175 / var(--tw-text-opacity))\n}button.round.svelte-babmty{display:flex;height:2.25rem;width:2.25rem;align-items:center;justify-content:center;border-radius:9999px;border-width:0px;padding:0.25rem\n}button.round.size-small.svelte-babmty{height:1.5rem;width:1.5rem\n}button.round.size-large.svelte-babmty{height:3rem;width:3rem\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLFVBQVUsQ0FBQTtBQUM3RixDQUFBLEFBRUMsTUFBTSxxQkFBTyxTQUFTLENBQ3RCLE1BQU0sT0FBTyxDQUFDLFFBQVEsZUFBQyxDQUN2QixNQUFNLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQyxjQUFDLENBQUEsQUFDN0IsZUFBZSxDQUFFLENBQUMsQ0FDbEIsZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUN6RCxpQkFBaUIsQ0FBRSxDQUFDLENBQ3BCLEtBQUssQ0FBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLENBQUE7QUFDakQsQ0FBQSxBQUVDLE1BQU0sb0JBQU0sU0FBUyxDQUNyQixNQUFNLE1BQU0sQ0FBQyxRQUFRLGVBQUMsQ0FDdEIsTUFBTSxNQUFNLE1BQU0sQ0FBQyxRQUFRLENBQUMsY0FBQyxDQUFBLEFBQzVCLGVBQWUsQ0FBRSxDQUFDLENBQ2xCLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksZUFBZSxDQUFDLENBQUMsQ0FDekQsaUJBQWlCLENBQUUsQ0FBQyxDQUNwQixLQUFLLENBQUUsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxpQkFBaUIsQ0FBQyxDQUFBO0FBQ2pELENBQUEsQUFFQyxNQUFNLE1BQU0sY0FBQyxDQUFBLEFBQ1osT0FBTyxDQUFFLElBQUksQ0FDYixNQUFNLENBQUUsT0FBTyxDQUNmLEtBQUssQ0FBRSxPQUFPLENBQ2QsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsZUFBZSxDQUFFLE1BQU0sQ0FDdkIsYUFBYSxDQUFFLE1BQU0sQ0FDckIsWUFBWSxDQUFFLEdBQUcsQ0FDakIsT0FBTyxDQUFFLE9BQUU7QUFDYixDQUFBLEFBRUMsTUFBTSxNQUFNLFdBQVcsY0FBQyxDQUFBLEFBQ3ZCLE1BQU0sQ0FBRSxNQUFNLENBQ2QsS0FBSyxDQUFFLE1BQUU7QUFDWCxDQUFBLEFBRUMsTUFBTSxNQUFNLFdBQVcsY0FBQyxDQUFBLEFBQ3ZCLE1BQU0sQ0FBRSxJQUFJLENBQ1osS0FBSyxDQUFFLElBQUE7QUFDVCxDQUFDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkJ1dHRvbi5zdmVsdGUiXX0= */");
}
function create_fragment(ctx) {
  let t;
  let button;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[8], null);
  const block = {
    c: function create() {
      t = space();
      button = element("button");
      if (default_slot)
        default_slot.c();
      attr_dev(button, "class", "marcelle svelte-babmty");
      button.disabled = ctx[2];
      toggle_class(button, "outline", ctx[1] === "outline");
      toggle_class(button, "filled", ctx[1] === "filled");
      toggle_class(button, "light", ctx[1] === "light");
      toggle_class(button, "success", ctx[3] === "success");
      toggle_class(button, "warning", ctx[3] === "warning");
      toggle_class(button, "danger", ctx[3] === "danger");
      toggle_class(button, "size-small", ctx[4] === "small");
      toggle_class(button, "size-large", ctx[4] === "large");
      toggle_class(button, "round", ctx[5]);
      add_location(button, file, 20, 0, 489);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
      insert_dev(target, button, anchor);
      if (default_slot) {
        default_slot.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            document.body,
            "mouseup",
            function() {
              if (is_function(ctx[0] && ctx[7]))
                (ctx[0] && ctx[7]).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(button, "click", ctx[10], false, false, false),
          listen_dev(button, "mousedown", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            ctx[8],
            !current ? get_all_dirty_from_scope(ctx[8]) : get_slot_changes(default_slot_template, ctx[8], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 4) {
        prop_dev(button, "disabled", ctx[2]);
      }
      if (!current || dirty & 2) {
        toggle_class(button, "outline", ctx[1] === "outline");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "filled", ctx[1] === "filled");
      }
      if (!current || dirty & 2) {
        toggle_class(button, "light", ctx[1] === "light");
      }
      if (!current || dirty & 8) {
        toggle_class(button, "success", ctx[3] === "success");
      }
      if (!current || dirty & 8) {
        toggle_class(button, "warning", ctx[3] === "warning");
      }
      if (!current || dirty & 8) {
        toggle_class(button, "danger", ctx[3] === "danger");
      }
      if (!current || dirty & 16) {
        toggle_class(button, "size-small", ctx[4] === "small");
      }
      if (!current || dirty & 16) {
        toggle_class(button, "size-large", ctx[4] === "large");
      }
      if (!current || dirty & 32) {
        toggle_class(button, "round", ctx[5]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
      if (detaching)
        detach_dev(button);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Button", slots, ["default"]);
  let { variant = "outline" } = $$props;
  let { disabled = false } = $$props;
  let { type = "default" } = $$props;
  let { size = "medium" } = $$props;
  let { round = false } = $$props;
  let { pressed = false } = $$props;
  const dispatch = createEventDispatcher();
  function startDown() {
    $$invalidate(0, pressed = true);
    dispatch("pressed", pressed);
  }
  function stopDown() {
    $$invalidate(0, pressed = false);
    dispatch("pressed", pressed);
  }
  const writable_props = ["variant", "disabled", "type", "size", "round", "pressed"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Button> was created with unknown prop '${key}'`);
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("round" in $$props2)
      $$invalidate(5, round = $$props2.round);
    if ("pressed" in $$props2)
      $$invalidate(0, pressed = $$props2.pressed);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    variant,
    disabled,
    type,
    size,
    round,
    pressed,
    dispatch,
    startDown,
    stopDown
  });
  $$self.$inject_state = ($$props2) => {
    if ("variant" in $$props2)
      $$invalidate(1, variant = $$props2.variant);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
    if ("size" in $$props2)
      $$invalidate(4, size = $$props2.size);
    if ("round" in $$props2)
      $$invalidate(5, round = $$props2.round);
    if ("pressed" in $$props2)
      $$invalidate(0, pressed = $$props2.pressed);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    pressed,
    variant,
    disabled,
    type,
    size,
    round,
    startDown,
    stopDown,
    $$scope,
    slots,
    click_handler
  ];
}
var Button = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        variant: 1,
        disabled: 2,
        type: 3,
        size: 4,
        round: 5,
        pressed: 0
      },
      add_css
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Button",
      options,
      id: create_fragment.name
    });
  }
  get variant() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get round() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set round(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get pressed() {
    throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set pressed(value) {
    throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Button_default = Button;

// node_modules/@marcellejs/design-system/dist/Input.svelte
var file2 = "node_modules/@marcellejs/design-system/dist/Input.svelte";
function add_css2(target) {
  append_styles(target, "svelte-t20lcy", "input.svelte-t20lcy{margin-right:0.25rem;margin-bottom:0.25rem;width:100%;border-radius:0.25rem;border-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));padding-left:1rem;padding-right:1rem;padding-top:0.5rem;padding-bottom:0.5rem;--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity));transition:all 0.15s ease\n}input.svelte-t20lcy::-moz-placeholder{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity))\n}input.svelte-t20lcy::placeholder{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity))\n}input.svelte-t20lcy:hover{--tw-border-opacity:1;border-color:rgb(156 163 175 / var(--tw-border-opacity))\n}input.svelte-t20lcy:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}input.svelte-t20lcy:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5\n}input.svelte-t20lcy:invalid{--tw-border-opacity:1;border-color:rgb(244 63 94 / var(--tw-border-opacity));--tw-text-opacity:1;color:rgb(225 29 72 / var(--tw-text-opacity))\n}input.svelte-t20lcy:invalid:focus{--tw-ring-opacity:1;--tw-ring-color:rgb(253 164 175 / var(--tw-ring-opacity))\n}input.svelte-t20lcy:disabled,input[disabled].svelte-t20lcy,input:hover[disabled].svelte-t20lcy{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_fragment2(ctx) {
  let input;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      attr_dev(input, "class", "marcelle svelte-t20lcy");
      input.disabled = ctx[2];
      attr_dev(input, "type", ctx[3]);
      attr_dev(input, "placeholder", ctx[1]);
      input.value = ctx[0];
      add_location(input, file2, 9, 0, 191);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(input, "input", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 4) {
        prop_dev(input, "disabled", ctx2[2]);
      }
      if (dirty & 8) {
        attr_dev(input, "type", ctx2[3]);
      }
      if (dirty & 2) {
        attr_dev(input, "placeholder", ctx2[1]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        prop_dev(input, "value", ctx2[0]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Input", slots, []);
  let { placeholder = "" } = $$props;
  let { disabled = false } = $$props;
  let { type = "text" } = $$props;
  let { value = null } = $$props;
  function handleInput(e) {
    $$invalidate(0, value = e.currentTarget.value);
  }
  const writable_props = ["placeholder", "disabled", "type", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Input> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    placeholder,
    disabled,
    type,
    value,
    handleInput
  });
  $$self.$inject_state = ($$props2) => {
    if ("placeholder" in $$props2)
      $$invalidate(1, placeholder = $$props2.placeholder);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
    if ("type" in $$props2)
      $$invalidate(3, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, placeholder, disabled, type, handleInput];
}
var Input = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance2,
      create_fragment2,
      safe_not_equal,
      {
        placeholder: 1,
        disabled: 2,
        type: 3,
        value: 0
      },
      add_css2
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Input",
      options,
      id: create_fragment2.name
    });
  }
  get placeholder() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Input_default = Input;

// node_modules/@marcellejs/design-system/dist/Modal.svelte
var file3 = "node_modules/@marcellejs/design-system/dist/Modal.svelte";
function add_css3(target) {
  append_styles(target, "svelte-nr9mik", ".modal-container.svelte-nr9mik{position:absolute;left:0px;right:0px;top:0px;z-index:20;min-height:100vh;padding:1rem;padding-bottom:1rem\n}@media(min-width: 640px){.modal-container.svelte-nr9mik{display:flex;align-items:center;justify-content:center\n    }}.overlay.svelte-nr9mik{position:absolute;top:0px;right:0px;bottom:0px;left:0px;min-height:100vh;transition-property:opacity;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms\n}.modal.svelte-nr9mik{transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));border-radius:0.5rem;--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-shadow:0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);transition-property:all;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms\n}@media(min-width: 640px){.modal.svelte-nr9mik{width:100%;max-width:48rem\n    }}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW9kYWwuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQW9CRSxnQkFBZ0IsY0FBQyxDQUFBLEFBRWYsUUFBUSxDQUFFLFFBQVEsQ0FFbEIsSUFBSSxDQUFFLEdBQUcsQ0FFVCxLQUFLLENBQUUsR0FBRyxDQUVWLEdBQUcsQ0FBRSxHQUFHLENBRVIsT0FBTyxDQUFFLEVBQUUsQ0FFWCxVQUFVLENBQUUsS0FBSyxDQUVqQixPQUFPLENBQUUsSUFBSSxDQUViLGNBQWMsQ0FBRSxJQUFBO0FBQ3BCLENBQUEsQUFFRSxNQUFNLEFBQUMsWUFBWSxLQUFLLENBQUMsQUFBQyxDQUFBLEFBQ3hCLGdCQUFnQixjQUFDLENBQUEsQUFFYixPQUFPLENBQUUsSUFBSSxDQUViLFdBQVcsQ0FBRSxNQUFNLENBRW5CLGVBQWUsQ0FBRSxNQUFBO0lBQ3JCLENBQUEsQUFDRixDQUFBLEFBRUEsUUFBUSxjQUFDLENBQUEsQUFFUCxRQUFRLENBQUUsUUFBUSxDQUVsQixHQUFHLENBQUUsR0FBRyxDQUVSLEtBQUssQ0FBRSxHQUFHLENBRVYsTUFBTSxDQUFFLEdBQUcsQ0FFWCxJQUFJLENBQUUsR0FBRyxDQUVULFVBQVUsQ0FBRSxLQUFLLENBRWpCLG1CQUFtQixDQUFFLE9BQU8sQ0FFNUIsMEJBQTBCLENBQUUsYUFBYSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FFeEQsbUJBQW1CLENBQUUsS0FBQTtBQUN6QixDQUFBLEFBRUUsTUFBTSxjQUFDLENBQUEsQUFFTCxTQUFTLENBQUUsVUFBVSxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxJQUFJLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxNQUFNLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxPQUFPLElBQUksWUFBWSxDQUFDLENBQUMsQ0FFL0wsYUFBYSxDQUFFLE1BQU0sQ0FFckIsZUFBZSxDQUFFLENBQUMsQ0FFbEIsZ0JBQWdCLENBQUUsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUV6RCxXQUFXLENBQUUsbUVBQW1FLENBRWhGLG1CQUFtQixDQUFFLCtFQUErRSxDQUVwRyxVQUFVLENBQUUsSUFBSSx1QkFBdUIsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUV2RyxtQkFBbUIsQ0FBRSxHQUFHLENBRXhCLDBCQUEwQixDQUFFLGFBQWEsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBRXhELG1CQUFtQixDQUFFLEtBQUE7QUFDekIsQ0FBQSxBQUVFLE1BQU0sQUFBQyxZQUFZLEtBQUssQ0FBQyxBQUFDLENBQUEsQUFDeEIsTUFBTSxjQUFDLENBQUEsQUFFSCxLQUFLLENBQUUsSUFBSSxDQUVYLFNBQVMsQ0FBRSxLQUFBO0lBQ2YsQ0FBQSxBQUNGLENBQUMiLCJuYW1lcyI6W10sInNvdXJjZXMiOlsiTW9kYWwuc3ZlbHRlIl19 */");
}
function create_fragment3(ctx) {
  let div3;
  let div1;
  let div0;
  let t;
  let div2;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[2], null);
  const block = {
    c: function create() {
      div3 = element("div");
      div1 = element("div");
      div0 = element("div");
      t = space();
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div0, "class", "absolute inset-0 bg-gray-500 opacity-50");
      add_location(div0, file3, 12, 4, 258);
      attr_dev(div1, "class", "overlay svelte-nr9mik");
      add_location(div1, file3, 11, 2, 232);
      attr_dev(div2, "class", "modal svelte-nr9mik");
      add_location(div2, file3, 14, 2, 351);
      attr_dev(div3, "class", "modal-container svelte-nr9mik");
      add_location(div3, file3, 10, 0, 200);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div3, anchor);
      append_dev(div3, div1);
      append_dev(div1, div0);
      append_dev(div3, t);
      append_dev(div3, div2);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div0, "click", ctx[0], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[2],
            !current ? get_all_dirty_from_scope(ctx2[2]) : get_slot_changes(default_slot_template, ctx2[2], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Modal", slots, ["default"]);
  const dispatch = createEventDispatcher();
  function quit() {
    dispatch("quit");
  }
  function onOutsideClick() {
    quit();
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Modal> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    dispatch,
    quit,
    onOutsideClick
  });
  return [onOutsideClick, quit, $$scope, slots];
}
var Modal = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { quit: 1 }, add_css3);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Modal",
      options,
      id: create_fragment3.name
    });
  }
  get quit() {
    return this.$$.ctx[1];
  }
  set quit(value) {
    throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Modal_default = Modal;

// node_modules/@marcellejs/design-system/dist/Notification.svelte
var file4 = "node_modules/@marcellejs/design-system/dist/Notification.svelte";
function add_css4(target) {
  append_styles(target, "svelte-r4ekig", ".notification-container.svelte-r4ekig{position:fixed;top:0px;right:0px;z-index:20;margin:0.5rem;display:flex;max-width:28rem;flex-direction:column;align-items:flex-end;justify-content:flex-end\n}.notification-card.svelte-r4ekig{margin-top:0.5rem;width:auto;border-radius:0.5rem;border-top-width:4px;padding-left:1rem;padding-right:1rem;padding-top:0.75rem;padding-bottom:0.75rem;--tw-shadow:0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);--tw-shadow-colored:0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)\n}.notification-card.default.svelte-r4ekig{--tw-border-opacity:1;border-color:rgb(20 184 166 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(204 251 241 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(19 78 74 / var(--tw-text-opacity))\n}.notification-card.danger.svelte-r4ekig{--tw-border-opacity:1;border-color:rgb(244 63 94 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 228 230 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(136 19 55 / var(--tw-text-opacity))\n}.notification-svg.svelte-r4ekig{height:1.5rem;width:1.5rem;fill:currentColor\n}.notification-svg.default.svelte-r4ekig{--tw-text-opacity:1;color:rgb(20 184 166 / var(--tw-text-opacity))\n}.notification-svg.danger.svelte-r4ekig{--tw-text-opacity:1;color:rgb(244 63 94 / var(--tw-text-opacity))\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i].title;
  child_ctx[6] = list[i].message;
  child_ctx[7] = list[i].type;
  child_ctx[8] = list[i].id;
  return child_ctx;
}
function create_if_block_1(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "d", "M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0\n                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 5h2v6H9V5zm0 8h2v2H9v-2z");
      add_location(path, file4, 49, 7, 1379);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(49:34) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      attr_dev(path, "d", "M2.93 17.07A10 10 0 1 1 17.07 2.93 10 10 0 0 1 2.93 17.07zm12.73-1.41A8 8 0 1 0\n                4.34 4.34a8 8 0 0 0 11.32 11.32zM9 11V9h2v6H9v-4zm0-6h2v2H9V5z");
      add_location(path, file4, 44, 7, 1150);
    },
    m: function mount(target, anchor) {
      insert_dev(target, path, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(44:6) {#if type === 'default'}",
    ctx
  });
  return block;
}
function create_each_block(key_1, ctx) {
  let div4;
  let div3;
  let div0;
  let svg0;
  let t0;
  let div1;
  let p0;
  let t1_value = ctx[5] + "";
  let t1;
  let t2;
  let p1;
  let t3_value = ctx[6] + "";
  let t3;
  let t4;
  let div2;
  let svg1;
  let title;
  let t5;
  let path;
  let t6;
  let div4_transition;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (ctx2[7] === "default")
      return create_if_block;
    if (ctx2[7] === "danger")
      return create_if_block_1;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type && current_block_type(ctx);
  function click_handler() {
    return ctx[3](ctx[8]);
  }
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      div4 = element("div");
      div3 = element("div");
      div0 = element("div");
      svg0 = svg_element("svg");
      if (if_block)
        if_block.c();
      t0 = space();
      div1 = element("div");
      p0 = element("p");
      t1 = text(t1_value);
      t2 = space();
      p1 = element("p");
      t3 = text(t3_value);
      t4 = space();
      div2 = element("div");
      svg1 = svg_element("svg");
      title = svg_element("title");
      t5 = text("Close");
      path = svg_element("path");
      t6 = space();
      attr_dev(svg0, "class", "notification-svg mr-4 svelte-r4ekig");
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg0, "viewBox", "0 0 20 20");
      toggle_class(svg0, "default", ctx[7] === "default");
      toggle_class(svg0, "danger", ctx[7] === "danger");
      add_location(svg0, file4, 36, 5, 917);
      attr_dev(div0, "class", "py-1");
      add_location(div0, file4, 35, 4, 893);
      attr_dev(p0, "class", "my-1 font-bold");
      add_location(p0, file4, 57, 5, 1613);
      attr_dev(p1, "class", "my-1 text-sm");
      add_location(p1, file4, 58, 5, 1656);
      add_location(div1, file4, 56, 4, 1602);
      add_location(title, file4, 71, 6, 2059);
      attr_dev(path, "d", "M14.348 14.849a1.2 1.2 0 0 1-1.697 0L10 11.819l-2.651 3.029a1.2 1.2 0 1\n              1-1.697-1.697l2.758-3.15-2.759-3.152a1.2 1.2 0 1 1 1.697-1.697L10\n              8.183l2.651-3.031a1.2 1.2 0 1 1 1.697 1.697l-2.758 3.152 2.758 3.15a1.2 1.2 0 0 1 0\n              1.698z");
      add_location(path, file4, 72, 6, 2086);
      attr_dev(svg1, "class", "notification-svg ml-4 cursor-pointer svelte-r4ekig");
      attr_dev(svg1, "role", "button");
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg1, "viewBox", "0 0 20 20");
      toggle_class(svg1, "default", ctx[7] === "default");
      toggle_class(svg1, "danger", ctx[7] === "danger");
      add_location(svg1, file4, 62, 5, 1790);
      add_location(div2, file4, 61, 4, 1779);
      attr_dev(div3, "class", "flex items-start");
      add_location(div3, file4, 34, 3, 858);
      attr_dev(div4, "class", "notification-card svelte-r4ekig");
      attr_dev(div4, "role", "alert");
      toggle_class(div4, "default", ctx[7] === "default");
      toggle_class(div4, "danger", ctx[7] === "danger");
      add_location(div4, file4, 26, 2, 675);
      this.first = div4;
    },
    m: function mount(target, anchor) {
      insert_dev(target, div4, anchor);
      append_dev(div4, div3);
      append_dev(div3, div0);
      append_dev(div0, svg0);
      if (if_block)
        if_block.m(svg0, null);
      append_dev(div3, t0);
      append_dev(div3, div1);
      append_dev(div1, p0);
      append_dev(p0, t1);
      append_dev(div1, t2);
      append_dev(div1, p1);
      append_dev(p1, t3);
      append_dev(div3, t4);
      append_dev(div3, div2);
      append_dev(div2, svg1);
      append_dev(svg1, title);
      append_dev(title, t5);
      append_dev(svg1, path);
      append_dev(div4, t6);
      current = true;
      if (!mounted) {
        dispose = listen_dev(svg1, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (current_block_type !== (current_block_type = select_block_type(ctx, dirty))) {
        if (if_block)
          if_block.d(1);
        if_block = current_block_type && current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(svg0, null);
        }
      }
      if (!current || dirty & 1) {
        toggle_class(svg0, "default", ctx[7] === "default");
      }
      if (!current || dirty & 1) {
        toggle_class(svg0, "danger", ctx[7] === "danger");
      }
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx[5] + ""))
        set_data_dev(t1, t1_value);
      if ((!current || dirty & 1) && t3_value !== (t3_value = ctx[6] + ""))
        set_data_dev(t3, t3_value);
      if (!current || dirty & 1) {
        toggle_class(svg1, "default", ctx[7] === "default");
      }
      if (!current || dirty & 1) {
        toggle_class(svg1, "danger", ctx[7] === "danger");
      }
      if (!current || dirty & 1) {
        toggle_class(div4, "default", ctx[7] === "default");
      }
      if (!current || dirty & 1) {
        toggle_class(div4, "danger", ctx[7] === "danger");
      }
    },
    r: function measure() {
      rect = div4.getBoundingClientRect();
    },
    f: function fix() {
      fix_position(div4);
      stop_animation();
      add_transform(div4, rect);
    },
    a: function animate() {
      stop_animation();
      stop_animation = create_animation(div4, rect, flip, {});
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div4_transition)
          div4_transition = create_bidirectional_transition(div4, blur, { amount: 10 }, true);
        div4_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div4_transition)
        div4_transition = create_bidirectional_transition(div4, blur, { amount: 10 }, false);
      div4_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div4);
      if (if_block) {
        if_block.d();
      }
      if (detaching && div4_transition)
        div4_transition.end();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(26:1) {#each notifications.slice(0, 10) as { title, message, type, id }",
    ctx
  });
  return block;
}
function create_fragment4(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ctx[0].slice(0, 10);
  validate_each_argument(each_value);
  const get_key = (ctx2) => ctx2[8];
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div, "class", "marcelle notification-container svelte-r4ekig");
      add_location(div, file4, 24, 0, 554);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0].slice(0, 10);
        validate_each_argument(each_value);
        group_outros();
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].r();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
        for (let i = 0; i < each_blocks.length; i += 1)
          each_blocks[i].a();
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Notification", slots, []);
  let { notifications = [] } = $$props;
  function close(id) {
    $$invalidate(0, notifications = notifications.filter((x) => x.id !== id));
  }
  let uid = 1;
  function add({ title, message, type = "default", duration = 3e3 }) {
    const n = { id: uid, title, message, type };
    uid += 1;
    $$invalidate(0, notifications = [...notifications, n]);
    if (duration > 0) {
      setTimeout(
        () => {
          close(n.id);
        },
        duration
      );
    }
  }
  const writable_props = ["notifications"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Notification> was created with unknown prop '${key}'`);
  });
  const click_handler = (id) => close(id);
  $$self.$$set = ($$props2) => {
    if ("notifications" in $$props2)
      $$invalidate(0, notifications = $$props2.notifications);
  };
  $$self.$capture_state = () => ({
    blur,
    flip,
    notifications,
    close,
    uid,
    add
  });
  $$self.$inject_state = ($$props2) => {
    if ("notifications" in $$props2)
      $$invalidate(0, notifications = $$props2.notifications);
    if ("uid" in $$props2)
      uid = $$props2.uid;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [notifications, close, add, click_handler];
}
var Notification = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, { notifications: 0, add: 2 }, add_css4);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Notification",
      options,
      id: create_fragment4.name
    });
  }
  get notifications() {
    throw new Error("<Notification>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notifications(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get add() {
    return this.$$.ctx[2];
  }
  set add(value) {
    throw new Error("<Notification>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Notification_default = Notification;

// node_modules/@marcellejs/design-system/dist/Number.svelte
var file5 = "node_modules/@marcellejs/design-system/dist/Number.svelte";
function add_css5(target) {
  append_styles(target, "svelte-9ymaj0", "input.svelte-9ymaj0{border-width:0px;border-top-width:1px;border-bottom-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));text-align:center;font-size:0.875rem;line-height:1.25rem;--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity));transition:all 0.15s ease}input.svelte-9ymaj0::-moz-placeholder{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity))}input.svelte-9ymaj0::placeholder{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity))}input.svelte-9ymaj0:hover{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity))}input.svelte-9ymaj0:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}input.svelte-9ymaj0:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}input.svelte-9ymaj0:disabled,input[disabled].svelte-9ymaj0,input:hover[disabled].svelte-9ymaj0{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}input.svelte-9ymaj0::-webkit-outer-spin-button,input.svelte-9ymaj0::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type='number'].svelte-9ymaj0{-moz-appearance:textfield}button.svelte-9ymaj0{margin:0px;cursor:pointer;border-radius:0.25rem;border-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));background-color:transparent;--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity));padding-top:0.25rem;padding-bottom:0.25rem;padding-left:0.5rem;padding-right:0.5rem;font-size:0.75rem;line-height:1rem;font-weight:400;text-transform:uppercase;--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity));outline:2px solid transparent;outline-offset:2px;transition:all 0.15s ease}button.svelte-9ymaj0:hover{--tw-border-opacity:1;border-color:rgb(14 165 233 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(240 249 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(14 165 233 / var(--tw-text-opacity))}button.svelte-9ymaj0:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}button.left.svelte-9ymaj0{border-top-right-radius:0px;border-bottom-right-radius:0px}button.right.svelte-9ymaj0{border-top-left-radius:0px;border-bottom-left-radius:0px}button.svelte-9ymaj0:disabled,button[disabled].svelte-9ymaj0,button:hover[disabled].svelte-9ymaj0{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_fragment5(ctx) {
  let div;
  let button0;
  let t0;
  let t1;
  let input;
  let t2;
  let button1;
  let t3;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      div = element("div");
      button0 = element("button");
      t0 = text("-");
      t1 = space();
      input = element("input");
      t2 = space();
      button1 = element("button");
      t3 = text("+");
      button0.disabled = ctx[1];
      attr_dev(button0, "class", "left svelte-9ymaj0");
      add_location(button0, file5, 15, 1, 294);
      attr_dev(input, "type", "number");
      attr_dev(input, "inputmode", "decimal");
      input.value = ctx[0];
      input.disabled = ctx[1];
      set_style(input, "width", "80px");
      attr_dev(input, "class", "svelte-9ymaj0");
      add_location(input, file5, 24, 1, 389);
      button1.disabled = ctx[1];
      attr_dev(button1, "class", "right svelte-9ymaj0");
      add_location(button1, file5, 32, 1, 510);
      attr_dev(div, "class", "flex");
      add_location(div, file5, 14, 0, 274);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, button0);
      append_dev(button0, t0);
      append_dev(div, t1);
      append_dev(div, input);
      append_dev(div, t2);
      append_dev(div, button1);
      append_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[3], false, false, false),
          listen_dev(input, "change", ctx[2], false, false, false),
          listen_dev(button1, "click", ctx[4], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 2) {
        prop_dev(button0, "disabled", ctx2[1]);
      }
      if (dirty & 1 && input.value !== ctx2[0]) {
        prop_dev(input, "value", ctx2[0]);
      }
      if (dirty & 2) {
        prop_dev(input, "disabled", ctx2[1]);
      }
      if (dirty & 2) {
        prop_dev(button1, "disabled", ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Number", slots, []);
  let { disabled = false } = $$props;
  let { value } = $$props;
  function changeValue(e) {
    const target = e.target;
    const x = parseFloat(target.value);
    if (!Number.isNaN(x)) {
      $$invalidate(0, value = x);
    } else {
      target.value = value.toString();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<Number> was created without expected prop 'value'");
    }
  });
  const writable_props = ["disabled", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Number> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    $$invalidate(0, value -= 1);
  };
  const click_handler_1 = () => {
    $$invalidate(0, value += 1);
  };
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({ disabled, value, changeValue });
  $$self.$inject_state = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, disabled, changeValue, click_handler, click_handler_1];
}
var Number_1 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { disabled: 1, value: 0 }, add_css5);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Number_1",
      options,
      id: create_fragment5.name
    });
  }
  get disabled() {
    throw new Error("<Number>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Number>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Number>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Number>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Number_default = Number_1;

// node_modules/@marcellejs/design-system/dist/NumberArray.svelte
var file6 = "node_modules/@marcellejs/design-system/dist/NumberArray.svelte";
function add_css6(target) {
  append_styles(target, "svelte-9ymaj0", "input.svelte-9ymaj0{border-width:0px;border-top-width:1px;border-bottom-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));text-align:center;font-size:0.875rem;line-height:1.25rem;--tw-text-opacity:1;color:rgb(31 41 55 / var(--tw-text-opacity));transition:all 0.15s ease}input.svelte-9ymaj0::-moz-placeholder{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity))}input.svelte-9ymaj0::placeholder{--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity))}input.svelte-9ymaj0:hover{--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity))}input.svelte-9ymaj0:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}input.svelte-9ymaj0:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}input.svelte-9ymaj0:disabled,input[disabled].svelte-9ymaj0,input:hover[disabled].svelte-9ymaj0{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}input.svelte-9ymaj0::-webkit-outer-spin-button,input.svelte-9ymaj0::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}input[type='number'].svelte-9ymaj0{-moz-appearance:textfield}button.svelte-9ymaj0{margin:0px;cursor:pointer;border-radius:0.25rem;border-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));background-color:transparent;--tw-bg-opacity:1;background-color:rgb(249 250 251 / var(--tw-bg-opacity));padding-top:0.25rem;padding-bottom:0.25rem;padding-left:0.5rem;padding-right:0.5rem;font-size:0.75rem;line-height:1rem;font-weight:400;text-transform:uppercase;--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity));outline:2px solid transparent;outline-offset:2px;transition:all 0.15s ease}button.svelte-9ymaj0:hover{--tw-border-opacity:1;border-color:rgb(14 165 233 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(240 249 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(14 165 233 / var(--tw-text-opacity))}button.svelte-9ymaj0:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}button.left.svelte-9ymaj0{border-top-right-radius:0px;border-bottom-right-radius:0px}button.right.svelte-9ymaj0{border-top-left-radius:0px;border-bottom-left-radius:0px}button.svelte-9ymaj0:disabled,button[disabled].svelte-9ymaj0,button:hover[disabled].svelte-9ymaj0{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(209 213 219 / var(--tw-text-opacity));--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  child_ctx[14] = i;
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  let t0;
  let button0;
  let t1;
  let t2;
  let button1;
  let t3;
  let mounted;
  let dispose;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t0 = space();
      button0 = element("button");
      t1 = text("-");
      t2 = space();
      button1 = element("button");
      t3 = text("+");
      button0.disabled = ctx[1];
      attr_dev(button0, "class", "left svelte-9ymaj0");
      add_location(button0, file6, 48, 2, 1092);
      button1.disabled = ctx[1];
      attr_dev(button1, "class", "right svelte-9ymaj0");
      set_style(button1, "border-left", "none");
      add_location(button1, file6, 49, 2, 1165);
      attr_dev(div, "class", "flex items-center");
      add_location(div, file6, 33, 1, 668);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append_dev(div, t0);
      append_dev(div, button0);
      append_dev(button0, t1);
      append_dev(div, t2);
      append_dev(div, button1);
      append_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", ctx[10], false, false, false),
          listen_dev(button1, "click", ctx[11], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 31) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, t0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 2) {
        prop_dev(button0, "disabled", ctx2[1]);
      }
      if (dirty & 2) {
        prop_dev(button1, "disabled", ctx2[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(33:0) {#if value && Array.isArray(value)}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let button0;
  let t0;
  let t1;
  let input;
  let input_value_value;
  let t2;
  let button1;
  let t3;
  let mounted;
  let dispose;
  function click_handler() {
    return ctx[7](ctx[14]);
  }
  function change_handler(...args) {
    return ctx[8](ctx[14], ...args);
  }
  function click_handler_1() {
    return ctx[9](ctx[14]);
  }
  const block = {
    c: function create() {
      div = element("div");
      button0 = element("button");
      t0 = text("-");
      t1 = space();
      input = element("input");
      t2 = space();
      button1 = element("button");
      t3 = text("+");
      button0.disabled = ctx[1];
      attr_dev(button0, "class", "left svelte-9ymaj0");
      add_location(button0, file6, 36, 4, 755);
      attr_dev(input, "type", "number");
      attr_dev(input, "inputmode", "decimal");
      input.value = input_value_value = ctx[12];
      input.disabled = ctx[1];
      set_style(input, "width", "80px");
      attr_dev(input, "class", "svelte-9ymaj0");
      add_location(input, file6, 37, 4, 834);
      button1.disabled = ctx[1];
      attr_dev(button1, "class", "right svelte-9ymaj0");
      add_location(button1, file6, 45, 4, 994);
      attr_dev(div, "class", "flex mr-2");
      add_location(div, file6, 35, 3, 727);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, button0);
      append_dev(button0, t0);
      append_dev(div, t1);
      append_dev(div, input);
      append_dev(div, t2);
      append_dev(div, button1);
      append_dev(button1, t3);
      if (!mounted) {
        dispose = [
          listen_dev(button0, "click", click_handler, false, false, false),
          listen_dev(input, "change", change_handler, false, false, false),
          listen_dev(button1, "click", click_handler_1, false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 2) {
        prop_dev(button0, "disabled", ctx[1]);
      }
      if (dirty & 1 && input_value_value !== (input_value_value = ctx[12]) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      if (dirty & 2) {
        prop_dev(input, "disabled", ctx[1]);
      }
      if (dirty & 2) {
        prop_dev(button1, "disabled", ctx[1]);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(35:2) {#each value as v, i}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let show_if = ctx[0] && Array.isArray(ctx[0]);
  let if_block_anchor;
  let if_block = show_if && create_if_block2(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1)
        show_if = ctx2[0] && Array.isArray(ctx2[0]);
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NumberArray", slots, []);
  let { disabled = false } = $$props;
  let { value } = $$props;
  function changeValue(e, i) {
    const target = e.target;
    const x = parseFloat(target.value);
    if (!Number.isNaN(x)) {
      $$invalidate(0, value[i] = x, value);
    } else {
      target.value = value[i].toString();
    }
  }
  function decrement(i) {
    const v = value.slice();
    v[i] -= 1;
    $$invalidate(0, value = v);
  }
  function increment(i) {
    const v = value.slice();
    v[i] += 1;
    $$invalidate(0, value = v);
  }
  function extend() {
    const v = value.slice();
    v.push(v.length ? v[v.length - 1] : 0);
    $$invalidate(0, value = v);
  }
  function reduce() {
    $$invalidate(0, value = value.slice(0, value.length - 1));
  }
  $$self.$$.on_mount.push(function() {
    if (value === void 0 && !("value" in $$props || $$self.$$.bound[$$self.$$.props["value"]])) {
      console.warn("<NumberArray> was created without expected prop 'value'");
    }
  });
  const writable_props = ["disabled", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NumberArray> was created with unknown prop '${key}'`);
  });
  const click_handler = (i) => decrement(i);
  const change_handler = (i, e) => changeValue(e, i);
  const click_handler_1 = (i) => increment(i);
  const click_handler_2 = () => reduce();
  const click_handler_3 = () => extend();
  $$self.$$set = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  $$self.$capture_state = () => ({
    disabled,
    value,
    changeValue,
    decrement,
    increment,
    extend,
    reduce
  });
  $$self.$inject_state = ($$props2) => {
    if ("disabled" in $$props2)
      $$invalidate(1, disabled = $$props2.disabled);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    disabled,
    changeValue,
    decrement,
    increment,
    extend,
    reduce,
    click_handler,
    change_handler,
    click_handler_1,
    click_handler_2,
    click_handler_3
  ];
}
var NumberArray = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { disabled: 1, value: 0 }, add_css6);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NumberArray",
      options,
      id: create_fragment6.name
    });
  }
  get disabled() {
    throw new Error("<NumberArray>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<NumberArray>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<NumberArray>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<NumberArray>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NumberArray_default = NumberArray;

// node_modules/@marcellejs/design-system/dist/PopMenu.svelte
var file7 = "node_modules/@marcellejs/design-system/dist/PopMenu.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_default_slot(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "d", "M10 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0-6a2 2 0 1 1 0-4 2 2 0 0 1 0 4zm0 12a2 2 0 1 1 0-4 2 2 0 0 1 0 4z");
      add_location(path, file7, 41, 4, 1076);
      attr_dev(svg, "class", "fill-current inline-block h-5 w-5");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 20 20");
      add_location(svg, file7, 37, 2, 961);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: '(37:1) <Button size=\\"small\\" round on:click={toggleDropdown}>',
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div2;
  let div1;
  let div0;
  let div2_transition;
  let current;
  let each_value = ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr_dev(div0, "class", "py-1");
      attr_dev(div0, "role", "menu");
      attr_dev(div0, "aria-orientation", "vertical");
      attr_dev(div0, "aria-labelledby", "options-menu");
      add_location(div0, file7, 56, 4, 1551);
      attr_dev(div1, "class", "origin-top-right absolute right-0 mt-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none");
      add_location(div1, file7, 53, 3, 1399);
      attr_dev(div2, "class", "origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg z-50");
      toggle_class(div2, "hidden", false);
      add_location(div2, file7, 48, 2, 1242);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div2, anchor);
      append_dev(div2, div1);
      append_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & 9) {
        each_value = ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: function intro(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!div2_transition)
          div2_transition = create_bidirectional_transition(div2, slide, { duration: 100 }, true);
        div2_transition.run(1);
      });
      current = true;
    },
    o: function outro(local) {
      if (!div2_transition)
        div2_transition = create_bidirectional_transition(div2, slide, { duration: 100 }, false);
      div2_transition.run(0);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div2);
      destroy_each(each_blocks, detaching);
      if (detaching && div2_transition)
        div2_transition.end();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(48:1) {#if showDropdown}",
    ctx
  });
  return block;
}
function create_each_block3(ctx) {
  let button;
  let t0_value = ctx[7].text + "";
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler_1() {
    return ctx[5](ctx[7]);
  }
  const block = {
    c: function create() {
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      attr_dev(button, "class", "text-sm py-2 px-4 font-normal block w-full whitespace-no-wrap bg-transparent text-gray-800 hover:bg-gray-100 border-0 cursor-pointer");
      add_location(button, file7, 58, 6, 1678);
    },
    m: function mount(target, anchor) {
      insert_dev(target, button, anchor);
      append_dev(button, t0);
      append_dev(button, t1);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & 1 && t0_value !== (t0_value = ctx[7].text + ""))
        set_data_dev(t0, t0_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(58:5) {#each actions as action}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let t0;
  let div;
  let button;
  let t1;
  let current;
  let mounted;
  let dispose;
  button = new Button_default({
    props: {
      size: "small",
      round: true,
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[2]);
  let if_block = ctx[1] && create_if_block3(ctx);
  const block = {
    c: function create() {
      t0 = space();
      div = element("div");
      create_component(button.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      attr_dev(div, "class", "relative");
      add_location(div, file7, 35, 0, 881);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      mount_component(button, div, null);
      append_dev(div, t1);
      if (if_block)
        if_block.m(div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(document.body, "click", ctx[4], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      const button_changes = {};
      if (dirty & 1024) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      destroy_component(button);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PopMenu", slots, []);
  let { actions = [] } = $$props;
  const dispatch = createEventDispatcher();
  let showDropdown = false;
  function toggleDropdown(e) {
    e.stopPropagation();
    if (showDropdown) {
      $$invalidate(1, showDropdown = false);
    } else {
      $$invalidate(1, showDropdown = true);
    }
  }
  function selectAction(code) {
    dispatch("select", code);
  }
  const writable_props = ["actions"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PopMenu> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    $$invalidate(1, showDropdown = false);
  };
  const click_handler_1 = (action) => selectAction(action.code);
  $$self.$$set = ($$props2) => {
    if ("actions" in $$props2)
      $$invalidate(0, actions = $$props2.actions);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    slide,
    Button: Button_default,
    actions,
    dispatch,
    showDropdown,
    toggleDropdown,
    selectAction
  });
  $$self.$inject_state = ($$props2) => {
    if ("actions" in $$props2)
      $$invalidate(0, actions = $$props2.actions);
    if ("showDropdown" in $$props2)
      $$invalidate(1, showDropdown = $$props2.showDropdown);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    actions,
    showDropdown,
    toggleDropdown,
    selectAction,
    click_handler,
    click_handler_1
  ];
}
var PopMenu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance7, create_fragment7, safe_not_equal, { actions: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PopMenu",
      options,
      id: create_fragment7.name
    });
  }
  get actions() {
    throw new Error("<PopMenu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actions(value) {
    throw new Error("<PopMenu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PopMenu_default = PopMenu;

// node_modules/@marcellejs/design-system/dist/Progress.svelte
var file8 = "node_modules/@marcellejs/design-system/dist/Progress.svelte";
function add_css7(target) {
  append_styles(target, "svelte-1w3676e", ".progress-line.svelte-1w3676e,.progress-line.svelte-1w3676e:before{margin-top:0.5rem;margin-bottom:0.5rem;height:0.5rem;width:100%;overflow:hidden;border-radius:0.25rem;font-size:0.75rem;line-height:1rem}.progress-line.thin.svelte-1w3676e,.progress-line.thin.svelte-1w3676e:before{margin-top:0.25rem;margin-bottom:0.25rem;height:0.25rem}.progress-line.svelte-1w3676e{display:flex;--tw-bg-opacity:1;background-color:rgb(186 230 253 / var(--tw-bg-opacity))}.progress-line.svelte-1w3676e:before,.progress-line.thin.svelte-1w3676e:before{margin-top:0px;margin-left:0px;--tw-bg-opacity:1;background-color:rgb(14 165 233 / var(--tw-bg-opacity));--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);content:'';margin-right:var(--bar-mr)}.gray.svelte-1w3676e{--tw-bg-opacity:1;background-color:rgb(229 231 235 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(75 85 99 / var(--tw-text-opacity))}.progress-line.gray.svelte-1w3676e:before{--tw-bg-opacity:1;background-color:rgb(107 114 128 / var(--tw-bg-opacity))}.green.svelte-1w3676e{--tw-bg-opacity:1;background-color:rgb(167 243 208 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(5 150 105 / var(--tw-text-opacity))}.progress-line.green.svelte-1w3676e:before{--tw-bg-opacity:1;background-color:rgb(16 185 129 / var(--tw-bg-opacity))}.red.svelte-1w3676e{--tw-bg-opacity:1;background-color:rgb(254 205 211 / var(--tw-bg-opacity));--tw-text-opacity:1;color:rgb(225 29 72 / var(--tw-text-opacity))}.progress-line.red.svelte-1w3676e:before{--tw-bg-opacity:1;background-color:rgb(244 63 94 / var(--tw-bg-opacity))}.progress-line.indeterminate.svelte-1w3676e:before{animation:svelte-1w3676e-running-progress 2s cubic-bezier(0.4, 0, 0.2, 1) infinite}@keyframes svelte-1w3676e-running-progress{0%{margin-left:0px;margin-right:100%}50%{margin-left:25%;margin-right:0%}100%{margin-left:100%;margin-right:0}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_fragment8(ctx) {
  let div;
  let div_style_value;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "class", "progress-line svelte-1w3676e");
      attr_dev(div, "style", div_style_value = ctx[0] >= 0 ? `--bar-mr: ${100 - Math.floor(ctx[0] * 100)}%;` : "--bar-mr: 0px");
      toggle_class(div, "thin", ctx[2]);
      toggle_class(div, "indeterminate", ctx[0] === void 0 || ctx[0] === null || ctx[0] < 0);
      toggle_class(div, "gray", ctx[1] === "idle");
      toggle_class(div, "green", ctx[1] === "success");
      toggle_class(div, "red", ctx[1] === "danger");
      add_location(div, file8, 5, 0, 94);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 1 && div_style_value !== (div_style_value = ctx2[0] >= 0 ? `--bar-mr: ${100 - Math.floor(ctx2[0] * 100)}%;` : "--bar-mr: 0px")) {
        attr_dev(div, "style", div_style_value);
      }
      if (dirty & 4) {
        toggle_class(div, "thin", ctx2[2]);
      }
      if (dirty & 1) {
        toggle_class(div, "indeterminate", ctx2[0] === void 0 || ctx2[0] === null || ctx2[0] < 0);
      }
      if (dirty & 2) {
        toggle_class(div, "gray", ctx2[1] === "idle");
      }
      if (dirty & 2) {
        toggle_class(div, "green", ctx2[1] === "success");
      }
      if (dirty & 2) {
        toggle_class(div, "red", ctx2[1] === "danger");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Progress", slots, []);
  let { progress } = $$props;
  let { type = "default" } = $$props;
  let { thin = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (progress === void 0 && !("progress" in $$props || $$self.$$.bound[$$self.$$.props["progress"]])) {
      console.warn("<Progress> was created without expected prop 'progress'");
    }
  });
  const writable_props = ["progress", "type", "thin"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Progress> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("thin" in $$props2)
      $$invalidate(2, thin = $$props2.thin);
  };
  $$self.$capture_state = () => ({ progress, type, thin });
  $$self.$inject_state = ($$props2) => {
    if ("progress" in $$props2)
      $$invalidate(0, progress = $$props2.progress);
    if ("type" in $$props2)
      $$invalidate(1, type = $$props2.type);
    if ("thin" in $$props2)
      $$invalidate(2, thin = $$props2.thin);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [progress, type, thin];
}
var Progress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { progress: 0, type: 1, thin: 2 }, add_css7);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Progress",
      options,
      id: create_fragment8.name
    });
  }
  get progress() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thin() {
    throw new Error("<Progress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thin(value) {
    throw new Error("<Progress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Progress_default = Progress;

// node_modules/@marcellejs/design-system/dist/Select.svelte
var file9 = "node_modules/@marcellejs/design-system/dist/Select.svelte";
function add_css8(target) {
  append_styles(target, "svelte-g3sqa4", ".select-container.svelte-g3sqa4{position:relative;display:inline-block;width:100%}select.svelte-g3sqa4{font-size:100%;margin:0;box-sizing:border-box;display:block;width:100%;cursor:pointer;-webkit-appearance:none;-moz-appearance:none;appearance:none;border-radius:0.25rem;border-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));padding-left:1rem;padding-top:0.5rem;padding-bottom:0.5rem;padding-right:2rem;font-size:0.75rem;line-height:1rem;line-height:1.25;--tw-text-opacity:1;color:rgb(55 65 81 / var(--tw-text-opacity));transition:all 0.15s ease}select.small.svelte-g3sqa4{padding-top:0.25rem;padding-bottom:0.25rem}select.svelte-g3sqa4:hover{--tw-border-opacity:1;border-color:rgb(156 163 175 / var(--tw-border-opacity))}select.svelte-g3sqa4:focus{outline:2px solid transparent;outline-offset:2px;--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}select.svelte-g3sqa4:active{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(4px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);--tw-ring-color:rgb(56 189 248 / var(--tw-ring-opacity));--tw-ring-opacity:0.5}option.svelte-g3sqa4{background-color:white}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block4(ctx) {
  let option;
  let t;
  const block = {
    c: function create() {
      option = element("option");
      t = text(ctx[2]);
      option.__value = "";
      option.value = option.__value;
      option.disabled = true;
      attr_dev(option, "class", "svelte-g3sqa4");
      add_location(option, file9, 15, 3, 400);
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 4)
        set_data_dev(t, ctx2[2]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(15:2) {#if placeholder}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let option;
  let t_value = ctx[7] + "";
  let t;
  let option_value_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = ctx[7];
      option.value = option.__value;
      attr_dev(option, "class", "svelte-g3sqa4");
      add_location(option, file9, 18, 3, 488);
    },
    m: function mount(target, anchor) {
      insert_dev(target, option, anchor);
      append_dev(option, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[7] + ""))
        set_data_dev(t, t_value);
      if (dirty & 2 && option_value_value !== (option_value_value = ctx2[7])) {
        prop_dev(option, "__value", option_value_value);
        option.value = option.__value;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(18:2) {#each options as option}",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let div1;
  let select;
  let if_block_anchor;
  let t;
  let div0;
  let svg;
  let path;
  let mounted;
  let dispose;
  let if_block = ctx[2] && create_if_block4(ctx);
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      select = element("select");
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      div0 = element("div");
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(select, "class", "svelte-g3sqa4");
      if (ctx[0] === void 0)
        add_render_callback(() => ctx[5].call(select));
      toggle_class(select, "small", ctx[3] === "small");
      add_location(select, file9, 9, 1, 257);
      attr_dev(path, "d", "M9.293 12.95l.707.707L15.657 8l-1.414-1.414L10 10.828 5.757 6.586 4.343 8z");
      add_location(path, file9, 23, 3, 744);
      attr_dev(svg, "class", "fill-current h-4 w-4");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "viewBox", "0 0 20 20");
      add_location(svg, file9, 22, 2, 651);
      attr_dev(div0, "class", "pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700");
      add_location(div0, file9, 21, 1, 551);
      attr_dev(div1, "class", "select-container svelte-g3sqa4");
      add_location(div1, file9, 8, 0, 225);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, select);
      if (if_block)
        if_block.m(select, null);
      append_dev(select, if_block_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(select, null);
      }
      select_option(select, ctx[0]);
      append_dev(div1, t);
      append_dev(div1, div0);
      append_dev(div0, svg);
      append_dev(svg, path);
      if (!mounted) {
        dispose = [
          listen_dev(select, "change", ctx[5]),
          listen_dev(select, "change", ctx[6], false, false, false)
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(select, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & 2) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & 3) {
        select_option(select, ctx2[0]);
      }
      if (dirty & 8) {
        toggle_class(select, "small", ctx2[3] === "small");
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, []);
  let { options } = $$props;
  let { value = "" } = $$props;
  let { placeholder = "Select an Option" } = $$props;
  let { size = "normal" } = $$props;
  const dispatch = createEventDispatcher();
  $$self.$$.on_mount.push(function() {
    if (options === void 0 && !("options" in $$props || $$self.$$.bound[$$self.$$.props["options"]])) {
      console.warn("<Select> was created without expected prop 'options'");
    }
  });
  const writable_props = ["options", "value", "placeholder", "size"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Select> was created with unknown prop '${key}'`);
  });
  function select_change_handler() {
    value = select_value(this);
    $$invalidate(0, value);
    $$invalidate(1, options);
  }
  const change_handler = (e) => dispatch("change", e.currentTarget.value);
  $$self.$$set = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    options,
    value,
    placeholder,
    size,
    dispatch
  });
  $$self.$inject_state = ($$props2) => {
    if ("options" in $$props2)
      $$invalidate(1, options = $$props2.options);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("placeholder" in $$props2)
      $$invalidate(2, placeholder = $$props2.placeholder);
    if ("size" in $$props2)
      $$invalidate(3, size = $$props2.size);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    value,
    options,
    placeholder,
    size,
    dispatch,
    select_change_handler,
    change_handler
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance9,
      create_fragment9,
      safe_not_equal,
      {
        options: 1,
        value: 0,
        placeholder: 2,
        size: 3
      },
      add_css8
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment9.name
    });
  }
  get options() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get placeholder() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set placeholder(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get size() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set size(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/@marcellejs/design-system/dist/Spinner.svelte
var file10 = "node_modules/@marcellejs/design-system/dist/Spinner.svelte";
function add_css9(target) {
  append_styles(target, "svelte-l56ytt", ".spinner-container.svelte-l56ytt{min-height:40px;position:absolute;top:0px;right:0px;bottom:0px;left:0px;display:flex;width:100%;flex-wrap:nowrap;align-items:center;justify-content:center;background-color:rgb(255 255 255 / var(--tw-bg-opacity));--tw-bg-opacity:0.5}.spinner.svelte-l56ytt{margin:30px auto;width:40px;height:40px;position:relative;text-align:center;animation:svelte-l56ytt-sk-rotate 2s infinite linear}.dot1.svelte-l56ytt,.dot2.svelte-l56ytt{--tw-bg-opacity:1;background-color:rgb(56 189 248 / var(--tw-bg-opacity));width:60%;height:60%;display:inline-block;position:absolute;top:0;border-radius:100%;animation:svelte-l56ytt-sk-bounce 2s infinite ease-in-out}.dot2.svelte-l56ytt{top:auto;bottom:0;animation-delay:-1s}@keyframes svelte-l56ytt-sk-rotate{100%{transform:rotate(360deg);-webkit-transform:rotate(360deg)}}@keyframes svelte-l56ytt-sk-bounce{0%,100%{transform:scale(0);-webkit-transform:scale(0)}50%{transform:scale(1);-webkit-transform:scale(1)}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3Bpbm5lci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBS0Msa0JBQWtCLGNBQUMsQ0FBQSxBQUNsQixVQUFVLENBQUUsSUFBSSxDQUNoQixRQUFRLENBQUUsUUFBUSxDQUNsQixHQUFHLENBQUUsR0FBRyxDQUNSLEtBQUssQ0FBRSxHQUFHLENBQ1YsTUFBTSxDQUFFLEdBQUcsQ0FDWCxJQUFJLENBQUUsR0FBRyxDQUNULE9BQU8sQ0FBRSxJQUFJLENBQ2IsS0FBSyxDQUFFLElBQUksQ0FDWCxTQUFTLENBQUUsTUFBTSxDQUNqQixXQUFXLENBQUUsTUFBTSxDQUNuQixlQUFlLENBQUUsTUFBTSxDQUN2QixnQkFBZ0IsQ0FBRSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUFDLENBQ3pELGVBQWUsQ0FBRSxHQUFHLEFBQ3JCLENBQUEsQUFFQSxRQUFRLGNBQUMsQ0FBQSxBQUNSLE1BQU0sQ0FBRSxJQUFJLENBQUMsSUFBSSxDQUNqQixLQUFLLENBQUUsSUFBSSxDQUNYLE1BQU0sQ0FBRSxJQUFJLENBQ1osUUFBUSxDQUFFLFFBQVEsQ0FDbEIsVUFBVSxDQUFFLE1BQU0sQ0FDbEIsU0FBUyxDQUFFLHVCQUFTLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEFBQ3hDLENBQUEsQUFFQSxtQkFBSyxDQUNMLEtBQUssY0FBQyxDQUFBLEFBQ0wsZUFBZSxDQUFFLENBQUMsQ0FDbEIsZ0JBQWdCLENBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxlQUFlLENBQUMsQ0FBQyxDQUN4RCxLQUFLLENBQUUsR0FBRyxDQUNWLE1BQU0sQ0FBRSxHQUFHLENBQ1gsT0FBTyxDQUFFLFlBQVksQ0FDckIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsR0FBRyxDQUFFLENBQUMsQ0FDTixhQUFhLENBQUUsSUFBSSxDQUNuQixTQUFTLENBQUUsdUJBQVMsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLFdBQVcsQUFDOUMsQ0FBQSxBQUVDLEtBQUssY0FBQyxDQUFBLEFBQ0wsR0FBRyxDQUFFLElBQUksQ0FDVCxNQUFNLENBQUUsQ0FBQyxDQUNULGVBQWUsQ0FBRSxHQUFHLEFBQ3JCLENBQUEsQUFDQSxXQUFXLHVCQUFVLENBQUEsQUFDcEIsSUFBSSxBQUFDLENBQUEsQUFDSixTQUFTLENBQUUsT0FBTyxNQUFNLENBQUMsQ0FDekIsaUJBQWlCLENBQUUsT0FBTyxNQUFNLENBQUMsQUFDbEMsQ0FBQSxBQUNELENBQUEsQUFFQSxXQUFXLHVCQUFVLENBQUEsQUFDcEIsRUFBRSxDQUNGLElBQUksQUFBQyxDQUFBLEFBQ0osU0FBUyxDQUFFLE1BQU0sQ0FBQyxDQUFDLENBQ25CLGlCQUFpQixDQUFFLE1BQU0sQ0FBQyxDQUFDLEFBQzVCLENBQUEsQUFDQSxHQUFHLEFBQUMsQ0FBQSxBQUNILFNBQVMsQ0FBRSxNQUFNLENBQUMsQ0FBQyxDQUNuQixpQkFBaUIsQ0FBRSxNQUFNLENBQUMsQ0FBQyxBQUM1QixDQUFBLEFBQ0QsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJTcGlubmVyLnN2ZWx0ZSJdfQ== */");
}
function create_fragment10(ctx) {
  let span3;
  let span2;
  let span0;
  let t;
  let span1;
  const block = {
    c: function create() {
      span3 = element("span");
      span2 = element("span");
      span0 = element("span");
      t = space();
      span1 = element("span");
      attr_dev(span0, "class", "dot1 svelte-l56ytt");
      add_location(span0, file10, 1, 24, 57);
      attr_dev(span1, "class", "dot2 svelte-l56ytt");
      add_location(span1, file10, 1, 46, 79);
      attr_dev(span2, "class", "spinner svelte-l56ytt");
      add_location(span2, file10, 1, 1, 34);
      attr_dev(span3, "class", "spinner-container svelte-l56ytt");
      add_location(span3, file10, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, span3, anchor);
      append_dev(span3, span2);
      append_dev(span2, span0);
      append_dev(span2, t);
      append_dev(span2, span1);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(span3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance10($$self, $$props) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Spinner", slots, []);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Spinner> was created with unknown prop '${key}'`);
  });
  return [];
}
var Spinner = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance10, create_fragment10, safe_not_equal, {}, add_css9);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Spinner",
      options,
      id: create_fragment10.name
    });
  }
};
var Spinner_default = Spinner;

// node_modules/@marcellejs/design-system/dist/Switch.svelte
var file11 = "node_modules/@marcellejs/design-system/dist/Switch.svelte";
function add_css10(target) {
  append_styles(target, "svelte-16fu7e0", "input.svelte-16fu7e0.svelte-16fu7e0{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border-width:0\n}.switch.svelte-16fu7e0.svelte-16fu7e0{position:relative;display:inline-block;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;user-select:none;background-color:transparent;vertical-align:middle\n}.track.svelte-16fu7e0.svelte-16fu7e0{position:relative;display:inline-block;height:1rem;width:2rem;border-radius:9999px;--tw-bg-opacity:1;background-color:rgb(209 213 219 / var(--tw-bg-opacity));--tw-shadow:inset 0 2px 4px 0 rgb(0 0 0 / 0.05);--tw-shadow-colored:inset 0 2px 4px 0 var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)\n}.thumb.svelte-16fu7e0.svelte-16fu7e0{position:absolute;display:inline-block;height:1.25rem;width:1.25rem;border-radius:9999px;border-width:1px;border-style:solid;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(255 255 255 / var(--tw-bg-opacity));transition-property:all;transition-duration:300ms;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);top:-0.125rem;left:-0.125rem\n}input[type='checkbox']:checked~.switch.svelte-16fu7e0 .thumb.svelte-16fu7e0{transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-border-opacity:1;border-color:rgb(14 165 233 / var(--tw-border-opacity));--tw-translate-x:calc(100% - 0.25rem)\n}input[type='checkbox']:checked~.switch.svelte-16fu7e0 .track.svelte-16fu7e0{transform:translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-bg-opacity:1;background-color:rgb(14 165 233 / var(--tw-bg-opacity));transition-property:color, background-color, border-color, text-decoration-color, fill, stroke;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-duration:150ms\n}input[type='checkbox']:disabled~.switch.svelte-16fu7e0 .track.svelte-16fu7e0{cursor:not-allowed;--tw-bg-opacity:1;background-color:rgb(209 213 219 / var(--tw-bg-opacity))\n}input[type='checkbox']:disabled:active+.switch.svelte-16fu7e0 .track.svelte-16fu7e0{--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)\n}input[type='checkbox']:disabled~.switch.svelte-16fu7e0 .thumb.svelte-16fu7e0{cursor:not-allowed;--tw-border-opacity:1;border-color:rgb(209 213 219 / var(--tw-border-opacity));--tw-bg-opacity:1;background-color:rgb(243 244 246 / var(--tw-bg-opacity))\n}input[type='checkbox']:focus+.switch.svelte-16fu7e0 .track.svelte-16fu7e0,input[type='checkbox']:active+.switch.svelte-16fu7e0 .track.svelte-16fu7e0{--tw-ring-offset-shadow:var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);--tw-ring-shadow:var(--tw-ring-inset) 0 0 0 calc(3px + var(--tw-ring-offset-width)) var(--tw-ring-color);box-shadow:var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,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 */");
}
function create_fragment11(ctx) {
  let label;
  let input;
  let t0;
  let span2;
  let span0;
  let t1;
  let span1;
  let t2;
  let span3;
  let t3;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      label = element("label");
      input = element("input");
      t0 = space();
      span2 = element("span");
      span0 = element("span");
      t1 = space();
      span1 = element("span");
      t2 = space();
      span3 = element("span");
      t3 = text(ctx[1]);
      attr_dev(input, "type", "checkbox");
      input.disabled = ctx[2];
      attr_dev(input, "class", "svelte-16fu7e0");
      add_location(input, file11, 6, 2, 125);
      attr_dev(span0, "class", "track svelte-16fu7e0");
      add_location(span0, file11, 8, 4, 203);
      attr_dev(span1, "class", "thumb svelte-16fu7e0");
      add_location(span1, file11, 9, 4, 230);
      attr_dev(span2, "class", "switch svelte-16fu7e0");
      add_location(span2, file11, 7, 2, 177);
      attr_dev(span3, "class", "ml-2 cursor-pointer");
      add_location(span3, file11, 11, 2, 265);
      attr_dev(label, "class", "marcelle");
      add_location(label, file11, 5, 0, 98);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, label, anchor);
      append_dev(label, input);
      input.checked = ctx[0];
      append_dev(label, t0);
      append_dev(label, span2);
      append_dev(span2, span0);
      append_dev(span2, t1);
      append_dev(span2, span1);
      append_dev(label, t2);
      append_dev(label, span3);
      append_dev(span3, t3);
      if (!mounted) {
        dispose = listen_dev(input, "change", ctx[3]);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 4) {
        prop_dev(input, "disabled", ctx2[2]);
      }
      if (dirty & 1) {
        input.checked = ctx2[0];
      }
      if (dirty & 2)
        set_data_dev(t3, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(label);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance11($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Switch", slots, []);
  let { text: text2 = "" } = $$props;
  let { checked = false } = $$props;
  let { disabled = false } = $$props;
  const writable_props = ["text", "checked", "disabled"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Switch> was created with unknown prop '${key}'`);
  });
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  $$self.$capture_state = () => ({ text: text2, checked, disabled });
  $$self.$inject_state = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("disabled" in $$props2)
      $$invalidate(2, disabled = $$props2.disabled);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [checked, text2, disabled, input_change_handler];
}
var Switch = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance11, create_fragment11, safe_not_equal, { text: 1, checked: 0, disabled: 2 }, add_css10);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Switch",
      options,
      id: create_fragment11.name
    });
  }
  get text() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set text(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checked() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checked(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Switch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Switch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Switch_default = Switch;

// node_modules/@marcellejs/design-system/dist/Tabs.svelte
var file12 = "node_modules/@marcellejs/design-system/dist/Tabs.svelte";
function create_fragment12(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "tabs");
      add_location(div, file12, 51, 0, 1190);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var TABS = {};
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tabs", slots, ["default"]);
  const tabs = [];
  const panels = [];
  const selectedTab = writable(null);
  const selectedPanel = writable(null);
  setContext(TABS, {
    registerTab: (tab) => {
      tabs.push(tab);
      selectedTab.update((current) => current || tab);
      onDestroy(() => {
        const i = tabs.indexOf(tab);
        tabs.splice(i, 1);
        selectedTab.update((current) => current === tab ? tabs[i] || tabs[tabs.length - 1] : current);
      });
    },
    registerPanel: (panel) => {
      panels.push(panel);
      selectedPanel.update((current) => current || panel);
      onDestroy(() => {
        const i = panels.indexOf(panel);
        panels.splice(i, 1);
        selectedPanel.update((current) => current === panel ? panels[i] || panels[panels.length - 1] : current);
      });
    },
    selectTab: (tab) => {
      const i = tabs.indexOf(tab);
      selectedTab.set(tab);
      selectedPanel.set(panels[i]);
    },
    selectedTab,
    selectedPanel
  });
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tabs> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    TABS,
    setContext,
    onDestroy,
    writable,
    tabs,
    panels,
    selectedTab,
    selectedPanel
  });
  return [$$scope, slots];
}
var Tabs = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance12, create_fragment12, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tabs",
      options,
      id: create_fragment12.name
    });
  }
};
var Tabs_default = Tabs;

// node_modules/@marcellejs/design-system/dist/Tab.svelte
var file13 = "node_modules/@marcellejs/design-system/dist/Tab.svelte";
function add_css11(target) {
  append_styles(target, "svelte-13dez5h", ".selected.svelte-13dez5h{border-width:0px;border-bottom-width:2px;border-style:solid;--tw-border-opacity:1;border-color:rgb(52 211 153 / var(--tw-border-opacity));--tw-text-opacity:1;color:rgb(0 0 0 / var(--tw-text-opacity))\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFiLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUFvQkMsU0FBUyxlQUFDLENBQUEsQUFDUCxZQUFZLENBQUUsR0FBRyxDQUNqQixtQkFBbUIsQ0FBRSxHQUFHLENBQ3hCLFlBQVksQ0FBRSxLQUFLLENBQ25CLG1CQUFtQixDQUFFLENBQUMsQ0FDdEIsWUFBWSxDQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksbUJBQW1CLENBQUMsQ0FBQyxDQUN4RCxpQkFBaUIsQ0FBRSxDQUFDLENBQ3BCLEtBQUssQ0FBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLGlCQUFpQixDQUFDLENBQUE7QUFDN0MsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUYWIuc3ZlbHRlIl19 */");
}
function create_fragment13(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = ctx[5].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[4], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "text-sm font-semibold text-gray-600 cursor-pointer mx-4 p-2 hover:text-gray-800 svelte-13dez5h");
      attr_dev(div, "role", "tab");
      toggle_class(div, "selected", ctx[0] === ctx[1]);
      add_location(div, file13, 10, 0, 202);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(div, "click", ctx[6], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[4],
            !current ? get_all_dirty_from_scope(ctx2[4]) : get_slot_changes(default_slot_template, ctx2[4], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 3) {
        toggle_class(div, "selected", ctx2[0] === ctx2[1]);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance13($$self, $$props, $$invalidate) {
  let $selectedTab;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default"]);
  const tab = {};
  const { registerTab, selectTab, selectedTab } = getContext(TABS);
  validate_store(selectedTab, "selectedTab");
  component_subscribe($$self, selectedTab, (value) => $$invalidate(0, $selectedTab = value));
  registerTab(tab);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Tab> was created with unknown prop '${key}'`);
  });
  const click_handler = () => selectTab(tab);
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(4, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    TABS,
    tab,
    registerTab,
    selectTab,
    selectedTab,
    $selectedTab
  });
  return [$selectedTab, tab, selectTab, selectedTab, $$scope, slots, click_handler];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance13, create_fragment13, safe_not_equal, {}, add_css11);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment13.name
    });
  }
};
var Tab_default = Tab;

// node_modules/@marcellejs/design-system/dist/TabPanel.svelte
function create_if_block5(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block5.name,
    type: "if",
    source: "(11:0) {#if $selectedPanel === panel}",
    ctx
  });
  return block;
}
function create_fragment14(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[0] === ctx[1] && create_if_block5(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[0] === ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block5(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance14($$self, $$props, $$invalidate) {
  let $selectedPanel;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabPanel", slots, ["default"]);
  const panel = {};
  const { registerPanel, selectedPanel } = getContext(TABS);
  validate_store(selectedPanel, "selectedPanel");
  component_subscribe($$self, selectedPanel, (value) => $$invalidate(0, $selectedPanel = value));
  registerPanel(panel);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TabPanel> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    TABS,
    panel,
    registerPanel,
    selectedPanel,
    $selectedPanel
  });
  return [$selectedPanel, panel, selectedPanel, $$scope, slots];
}
var TabPanel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance14, create_fragment14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabPanel",
      options,
      id: create_fragment14.name
    });
  }
};
var TabPanel_default = TabPanel;

// node_modules/@marcellejs/design-system/dist/TableContentCell.svelte
var { console: console_1 } = globals;
var file14 = "node_modules/@marcellejs/design-system/dist/TableContentCell.svelte";
function add_css12(target) {
  append_styles(target, "svelte-1w1eb18", "td.svelte-1w1eb18{white-space:nowrap;padding-left:1rem;padding-right:1rem;padding-top:0.25rem;padding-bottom:0.25rem}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVDb250ZW50Q2VsbC5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBdURDLEVBQUUsZUFBQyxDQUFBLEFBQ0YsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsWUFBWSxDQUFFLElBQUksQ0FDbEIsYUFBYSxDQUFFLElBQUksQ0FDbkIsV0FBVyxDQUFFLE9BQU8sQ0FDcEIsY0FBYyxDQUFFLE9BQU8sQUFDeEIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUYWJsZUNvbnRlbnRDZWxsLnN2ZWx0ZSJdfQ== */");
}
function create_else_block(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(50:1) {:else}",
    ctx
  });
  return block;
}
function create_if_block_6(ctx) {
  let t_value = ctx[1].toPrecision(2) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].toPrecision(2) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(48:37) ",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let t0;
  let t1_value = getArrayShape(ctx[1]).join(", ") + "";
  let t1;
  let t2;
  const block = {
    c: function create() {
      t0 = text("Array(");
      t1 = text(t1_value);
      t2 = text(")");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, t2, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t1_value !== (t1_value = getArrayShape(ctx2[1]).join(", ") + ""))
        set_data_dev(t1, t1_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(t1);
      if (detaching)
        detach_dev(t2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(46:28) ",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let t_value = ctx[3](ctx[1]) + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[3](ctx2[1]) + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(44:27) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let current;
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[7], null);
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[7],
            !current ? get_all_dirty_from_scope(ctx2[7]) : get_slot_changes(default_slot_template, ctx2[7], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(42:27) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      size: "small",
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[6]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 130) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(40:29) ",
    ctx
  });
  return block;
}
function create_if_block_12(ctx) {
  let sl_button;
  let t_value = ctx[1].text + "";
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      sl_button = element("sl-button");
      t = text(t_value);
      set_custom_element_data(sl_button, "type", "text");
      set_custom_element_data(sl_button, "size", "small");
      add_location(sl_button, file14, 31, 2, 949);
    },
    m: function mount(target, anchor) {
      insert_dev(target, sl_button, anchor);
      append_dev(sl_button, t);
      if (!mounted) {
        dispose = listen_dev(sl_button, "click", ctx[5], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[1].text + ""))
        set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(sl_button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(31:27) ",
    ctx
  });
  return block;
}
function create_if_block6(ctx) {
  let img;
  let img_src_value;
  const block = {
    c: function create() {
      img = element("img");
      attr_dev(img, "alt", "thumbnail");
      if (!src_url_equal(img.src, img_src_value = ctx[1]))
        attr_dev(img, "src", img_src_value);
      attr_dev(img, "width", "30");
      attr_dev(img, "height", "30");
      attr_dev(img, "class", "rounded-md");
      add_location(img, file14, 29, 2, 841);
    },
    m: function mount(target, anchor) {
      insert_dev(target, img, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && !src_url_equal(img.src, img_src_value = ctx2[1])) {
        attr_dev(img, "src", img_src_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(img);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block6.name,
    type: "if",
    source: "(29:1) {#if type === 'image'}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(ctx[1]);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2)
        set_data_dev(t, ctx2[1]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: `(41:2) <Button size=\\"small\\" on:click={() => dispatch('action', value)}>`,
    ctx
  });
  return block;
}
function create_fragment15(ctx) {
  let td;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [
    create_if_block6,
    create_if_block_12,
    create_if_block_2,
    create_if_block_3,
    create_if_block_4,
    create_if_block_5,
    create_if_block_6,
    create_else_block
  ];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[0] === "image")
      return 0;
    if (ctx2[0] === "link")
      return 1;
    if (ctx2[0] === "action")
      return 2;
    if (ctx2[0] === "slot")
      return 3;
    if (ctx2[0] === "date")
      return 4;
    if (ctx2[0] === "array")
      return 5;
    if (typeof ctx2[1] === "number")
      return 6;
    return 7;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      td = element("td");
      if_block.c();
      attr_dev(td, "class", "svelte-1w1eb18");
      add_location(td, file14, 27, 0, 810);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, td, anchor);
      if_blocks[current_block_type_index].m(td, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(td, null);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(td);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function getArrayShape(arr) {
  if (!Array.isArray(arr))
    return [];
  if (arr.length > 0 && Array.isArray(arr[0])) {
    return [arr.length, ...getArrayShape(arr[0])];
  }
  return [arr.length];
}
function instance15($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableContentCell", slots, ["default"]);
  let { type = "generic" } = $$props;
  let { value = null } = $$props;
  const dispatch = createEventDispatcher();
  function formatDate(v) {
    try {
      return formatDistanceToNow(Date.parse(v), { includeSeconds: true, addSuffix: true });
    } catch (error) {
      console.log("Date Parsing Error", v, error);
      return v;
    }
  }
  const writable_props = ["type", "value"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console_1.warn(`<TableContentCell> was created with unknown prop '${key}'`);
  });
  const click_handler = () => {
    console.log("GOTO:", value.href);
  };
  const click_handler_1 = () => dispatch("action", value);
  $$self.$$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
    if ("$$scope" in $$props2)
      $$invalidate(7, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    formatDistanceToNow,
    createEventDispatcher,
    Button: Button_default,
    type,
    value,
    dispatch,
    getArrayShape,
    formatDate
  });
  $$self.$inject_state = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
    if ("value" in $$props2)
      $$invalidate(1, value = $$props2.value);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    type,
    value,
    dispatch,
    formatDate,
    slots,
    click_handler,
    click_handler_1,
    $$scope
  ];
}
var TableContentCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance15, create_fragment15, safe_not_equal, { type: 0, value: 1 }, add_css12);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableContentCell",
      options,
      id: create_fragment15.name
    });
  }
  get type() {
    throw new Error("<TableContentCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<TableContentCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<TableContentCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TableContentCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableContentCell_default = TableContentCell;

// node_modules/@marcellejs/design-system/dist/TableHeaderCell.svelte
var file15 = "node_modules/@marcellejs/design-system/dist/TableHeaderCell.svelte";
function add_css13(target) {
  append_styles(target, "svelte-1310j1m", "th.svelte-1310j1m{text-align:left;padding-left:1rem;padding-right:1rem;padding-top:0.75rem;padding-bottom:0.75rem;line-height:1rem;font-weight:500;color:rgb(107, 114, 128);letter-spacing:0.05em}sl-icon-button::part(base){color:transparent}sl-icon-button.hover::part(base){color:var(--sl-color-gray-500)}sl-icon-button.active::part(base){color:var(--sl-color-success-500)}sl-icon-button::part(base):hover{color:var(--sl-color-primary-500)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVIZWFkZXJDZWxsLnN2ZWx0ZSIsIm1hcHBpbmdzIjoiQUE4REMsRUFBRSxlQUFDLENBQUEsQUFDRixVQUFVLENBQUUsSUFBSSxDQUNoQixZQUFZLENBQUUsSUFBSSxDQUNsQixhQUFhLENBQUUsSUFBSSxDQUNuQixXQUFXLENBQUUsT0FBTyxDQUNwQixjQUFjLENBQUUsT0FBTyxDQUN2QixXQUFXLENBQUUsSUFBSSxDQUNqQixXQUFXLENBQUUsR0FBRyxDQUNoQixLQUFLLENBQUUsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDekIsY0FBYyxDQUFFLE1BQU0sQUFDdkIsQ0FBQSxBQUVRLDBCQUEwQixBQUFFLENBQUEsQUFDbkMsS0FBSyxDQUFFLFdBQVcsQUFDbkIsQ0FBQSxBQUVRLGdDQUFnQyxBQUFFLENBQUEsQUFDekMsS0FBSyxDQUFFLElBQUksbUJBQW1CLENBQUMsQUFDaEMsQ0FBQSxBQUVRLGlDQUFpQyxBQUFFLENBQUEsQUFDMUMsS0FBSyxDQUFFLElBQUksc0JBQXNCLENBQUMsQUFDbkMsQ0FBQSxBQUVRLGdDQUFnQyxBQUFFLENBQUEsQUFDekMsS0FBSyxDQUFFLElBQUksc0JBQXNCLENBQUMsQUFDbkMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUYWJsZUhlYWRlckNlbGwuc3ZlbHRlIl19 */");
}
function create_if_block7(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_13, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[2])
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block7.name,
    type: "if",
    source: "(20:2) {#if sortable}",
    ctx
  });
  return block;
}
function create_else_block2(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      round: true,
      size: "small",
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[3]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 64) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(40:3) {:else}",
    ctx
  });
  return block;
}
function create_if_block_13(ctx) {
  let button;
  let current;
  button = new Button_default({
    props: {
      round: true,
      size: "small",
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", ctx[3]);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const button_changes = {};
      if (dirty & 64) {
        button_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_13.name,
    type: "if",
    source: "(21:3) {#if sortAscending}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "stroke-width", "2");
      attr_dev(path, "d", "M16 17l-4 4m0 0l-4-4m4 4V3");
      add_location(path, file15, 48, 6, 1333);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "h-6 w-6");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      add_location(svg, file15, 41, 5, 1180);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: '(41:4) <Button round size=\\"small\\" on:click={sort}>',
    ctx
  });
  return block;
}
function create_default_slot3(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "stroke-width", "2");
      attr_dev(path, "d", "M8 7l4-4m0 0l4 4m-4-4v18");
      add_location(path, file15, 31, 6, 954);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "h-6 w-6");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      add_location(svg, file15, 24, 5, 801);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: '(22:4) <Button round size=\\"small\\" on:click={sort}>',
    ctx
  });
  return block;
}
function create_fragment16(ctx) {
  let th;
  let span1;
  let span0;
  let t0;
  let t1;
  let current;
  let if_block = ctx[1] && create_if_block7(ctx);
  const block = {
    c: function create() {
      th = element("th");
      span1 = element("span");
      span0 = element("span");
      t0 = text(ctx[0]);
      t1 = space();
      if (if_block)
        if_block.c();
      set_style(span0, "margin-top", "0.5rem");
      set_style(span0, "margin-bottom", "0.5rem");
      add_location(span0, file15, 18, 2, 561);
      set_style(span1, "display", "flex");
      set_style(span1, "justify-content", "space-between");
      set_style(span1, "align-items", "center");
      add_location(span1, file15, 17, 1, 476);
      attr_dev(th, "class", "svelte-1310j1m");
      add_location(th, file15, 16, 0, 470);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      append_dev(th, span1);
      append_dev(span1, span0);
      append_dev(span0, t0);
      append_dev(span1, t1);
      if (if_block)
        if_block.m(span1, null);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & 1)
        set_data_dev(t0, ctx2[0]);
      if (ctx2[1]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block7(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(span1, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance16($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableHeaderCell", slots, []);
  let { name = "name" } = $$props;
  let { sortable = false } = $$props;
  let { sorting = { col: "", ascending: true } } = $$props;
  const dispatch = createEventDispatcher();
  let sortAscending = true;
  function sort() {
    $$invalidate(2, sortAscending = !sortAscending);
    dispatch("sort", { col: name, ascending: sortAscending });
  }
  const writable_props = ["name", "sortable", "sorting"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TableHeaderCell> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("sortable" in $$props2)
      $$invalidate(1, sortable = $$props2.sortable);
    if ("sorting" in $$props2)
      $$invalidate(4, sorting = $$props2.sorting);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Button: Button_default,
    name,
    sortable,
    sorting,
    dispatch,
    sortAscending,
    sort
  });
  $$self.$inject_state = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(0, name = $$props2.name);
    if ("sortable" in $$props2)
      $$invalidate(1, sortable = $$props2.sortable);
    if ("sorting" in $$props2)
      $$invalidate(4, sorting = $$props2.sorting);
    if ("sortAscending" in $$props2)
      $$invalidate(2, sortAscending = $$props2.sortAscending);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 17) {
      $:
        if (sorting.col === name) {
          $$invalidate(2, sortAscending = sorting.ascending);
        }
    }
  };
  return [name, sortable, sortAscending, sort, sorting];
}
var TableHeaderCell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance16, create_fragment16, safe_not_equal, { name: 0, sortable: 1, sorting: 4 }, add_css13);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableHeaderCell",
      options,
      id: create_fragment16.name
    });
  }
  get name() {
    throw new Error("<TableHeaderCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<TableHeaderCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<TableHeaderCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<TableHeaderCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sorting() {
    throw new Error("<TableHeaderCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sorting(value) {
    throw new Error("<TableHeaderCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableHeaderCell_default = TableHeaderCell;

// node_modules/@marcellejs/design-system/dist/TableActions.svelte
var file16 = "node_modules/@marcellejs/design-system/dist/TableActions.svelte";
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i].name;
  child_ctx[11] = list[i].multiple;
  child_ctx[12] = list[i].confirm;
  return child_ctx;
}
function create_default_slot_3(ctx) {
  let t_value = ctx[10] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & 2 && t_value !== (t_value = ctx2[10] + ""))
        set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: `(39:4) <Button       size=\\"small\\"       disabled={multiple === false && selected.length > 1}       type={name === 'delete' ? 'danger' : 'default'}       on:click={() => handleAction(name, confirm)}>`,
    ctx
  });
  return block;
}
function create_each_block5(ctx) {
  let button;
  let current;
  function click_handler() {
    return ctx[7](ctx[10], ctx[12]);
  }
  button = new Button_default({
    props: {
      size: "small",
      disabled: ctx[11] === false && ctx[0].length > 1,
      type: ctx[10] === "delete" ? "danger" : "default",
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button.$on("click", click_handler);
  const block = {
    c: function create() {
      create_component(button.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(button, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const button_changes = {};
      if (dirty & 3)
        button_changes.disabled = ctx[11] === false && ctx[0].length > 1;
      if (dirty & 2)
        button_changes.type = ctx[10] === "delete" ? "danger" : "default";
      if (dirty & 32770) {
        button_changes.$$scope = { dirty, ctx };
      }
      button.$set(button_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(button, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(38:2) {#each actions as { name, multiple, confirm }}",
    ctx
  });
  return block;
}
function create_if_block8(ctx) {
  let modal;
  let current;
  modal = new Modal_default({
    props: {
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(modal.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(modal, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const modal_changes = {};
      if (dirty & 32780) {
        modal_changes.$$scope = { dirty, ctx: ctx2 };
      }
      modal.$set(modal_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(modal.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(modal.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(modal, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block8.name,
    type: "if",
    source: "(49:0) {#if confirmActionPending}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Cancel");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: '(54:8) <Button           type=\\"danger\\"           on:click={() => {             confirmActionPending = false;           }}>',
    ctx
  });
  return block;
}
function create_default_slot_12(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text("Confirm");
    },
    m: function mount(target, anchor) {
      insert_dev(target, t, anchor);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_12.name,
    type: "slot",
    source: '(61:8) <Button variant=\\"filled\\" on:click={confirmAction}>',
    ctx
  });
  return block;
}
function create_default_slot4(ctx) {
  let div1;
  let p;
  let t0;
  let t1;
  let t2;
  let t3;
  let div0;
  let button0;
  let t4;
  let span;
  let t5;
  let button1;
  let current;
  button0 = new Button_default({
    props: {
      type: "danger",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on("click", ctx[8]);
  button1 = new Button_default({
    props: {
      variant: "filled",
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on("click", ctx[4]);
  const block = {
    c: function create() {
      div1 = element("div");
      p = element("p");
      t0 = text("Do you want to ");
      t1 = text(ctx[2]);
      t2 = text(" the selected items?");
      t3 = space();
      div0 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      span = element("span");
      t5 = space();
      create_component(button1.$$.fragment);
      add_location(p, file16, 51, 6, 1295);
      attr_dev(span, "class", "w-2");
      add_location(span, file16, 59, 8, 1554);
      attr_dev(div0, "class", "w-full flex justify-end");
      add_location(div0, file16, 52, 6, 1360);
      attr_dev(div1, "class", "p-8");
      add_location(div1, file16, 50, 4, 1271);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div1, anchor);
      append_dev(div1, p);
      append_dev(p, t0);
      append_dev(p, t1);
      append_dev(p, t2);
      append_dev(div1, t3);
      append_dev(div1, div0);
      mount_component(button0, div0, null);
      append_dev(div0, t4);
      append_dev(div0, span);
      append_dev(div0, t5);
      mount_component(button1, div0, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!current || dirty & 4)
        set_data_dev(t1, ctx2[2]);
      const button0_changes = {};
      if (dirty & 32768) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty & 32768) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      destroy_component(button0);
      destroy_component(button1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot4.name,
    type: "slot",
    source: "(50:2) <Modal>",
    ctx
  });
  return block;
}
function create_fragment17(ctx) {
  let div;
  let t;
  let if_block_anchor;
  let current;
  let each_value = ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block = ctx[3] && create_if_block8(ctx);
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      attr_dev(div, "class", "actions");
      add_location(div, file16, 36, 0, 909);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      insert_dev(target, t, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & 35) {
        each_value = ctx2[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block8(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(t);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance17($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableActions", slots, []);
  let { provider } = $$props;
  let { actions } = $$props;
  let { selected } = $$props;
  const dispatch = createEventDispatcher();
  let selectedAction = "";
  let confirmActionPending = false;
  async function confirmAction() {
    if (selectedAction === "delete") {
      for (const i of selected) {
        await provider.delete(i);
      }
    } else {
      dispatch("action", [selectedAction, selected]);
    }
    $$invalidate(3, confirmActionPending = false);
    $$invalidate(0, selected = []);
    dispatch("selected", selected);
  }
  function handleAction(action, confirm) {
    $$invalidate(2, selectedAction = action);
    if (!selectedAction || selected.length === 0)
      return;
    if (confirm) {
      $$invalidate(3, confirmActionPending = true);
    } else {
      confirmAction();
    }
  }
  $$self.$$.on_mount.push(function() {
    if (provider === void 0 && !("provider" in $$props || $$self.$$.bound[$$self.$$.props["provider"]])) {
      console.warn("<TableActions> was created without expected prop 'provider'");
    }
    if (actions === void 0 && !("actions" in $$props || $$self.$$.bound[$$self.$$.props["actions"]])) {
      console.warn("<TableActions> was created without expected prop 'actions'");
    }
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<TableActions> was created without expected prop 'selected'");
    }
  });
  const writable_props = ["provider", "actions", "selected"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TableActions> was created with unknown prop '${key}'`);
  });
  const click_handler = (name, confirm) => handleAction(name, confirm);
  const click_handler_1 = () => {
    $$invalidate(3, confirmActionPending = false);
  };
  $$self.$$set = ($$props2) => {
    if ("provider" in $$props2)
      $$invalidate(6, provider = $$props2.provider);
    if ("actions" in $$props2)
      $$invalidate(1, actions = $$props2.actions);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    Button: Button_default,
    Modal: Modal_default,
    provider,
    actions,
    selected,
    dispatch,
    selectedAction,
    confirmActionPending,
    confirmAction,
    handleAction
  });
  $$self.$inject_state = ($$props2) => {
    if ("provider" in $$props2)
      $$invalidate(6, provider = $$props2.provider);
    if ("actions" in $$props2)
      $$invalidate(1, actions = $$props2.actions);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("selectedAction" in $$props2)
      $$invalidate(2, selectedAction = $$props2.selectedAction);
    if ("confirmActionPending" in $$props2)
      $$invalidate(3, confirmActionPending = $$props2.confirmActionPending);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    selected,
    actions,
    selectedAction,
    confirmActionPending,
    confirmAction,
    handleAction,
    provider,
    click_handler,
    click_handler_1
  ];
}
var TableActions = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance17, create_fragment17, safe_not_equal, { provider: 6, actions: 1, selected: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableActions",
      options,
      id: create_fragment17.name
    });
  }
  get provider() {
    throw new Error("<TableActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set provider(value) {
    throw new Error("<TableActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actions() {
    throw new Error("<TableActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actions(value) {
    throw new Error("<TableActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<TableActions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TableActions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableActions_default = TableActions;

// node_modules/@marcellejs/design-system/dist/TableFooter.svelte
var file17 = "node_modules/@marcellejs/design-system/dist/TableFooter.svelte";
function add_css14(target) {
  append_styles(target, "svelte-13k2ee6", ".table-footer.svelte-13k2ee6{display:flex;justify-content:space-between;align-items:center;padding-left:0.5rem;padding-right:0.5rem;padding-top:0.75rem;padding-bottom:0.75rem;border-top:1px solid rgb(229, 231, 235)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGVGb290ZXIuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQXFIQyxhQUFhLGVBQUMsQ0FBQSxBQUNiLE9BQU8sQ0FBRSxJQUFJLENBQ2IsZUFBZSxDQUFFLGFBQWEsQ0FDOUIsV0FBVyxDQUFFLE1BQU0sQ0FDbkIsWUFBWSxDQUFFLE1BQU0sQ0FDcEIsYUFBYSxDQUFFLE1BQU0sQ0FDckIsV0FBVyxDQUFFLE9BQU8sQ0FDcEIsY0FBYyxDQUFFLE9BQU8sQ0FDdkIsVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDekMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUYWJsZUZvb3Rlci5zdmVsdGUiXX0= */");
}
function create_if_block9(ctx) {
  let tableactions;
  let updating_selected;
  let current;
  function tableactions_selected_binding(value) {
    ctx[11](value);
  }
  let tableactions_props = {
    provider: ctx[1],
    actions: ctx[2]
  };
  if (ctx[0] !== void 0) {
    tableactions_props.selected = ctx[0];
  }
  tableactions = new TableActions_default({
    props: tableactions_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(tableactions, "selected", tableactions_selected_binding));
  tableactions.$on("selected", ctx[12]);
  tableactions.$on("action", ctx[13]);
  const block = {
    c: function create() {
      create_component(tableactions.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tableactions, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tableactions_changes = {};
      if (dirty & 2)
        tableactions_changes.provider = ctx2[1];
      if (dirty & 4)
        tableactions_changes.actions = ctx2[2];
      if (!updating_selected && dirty & 1) {
        updating_selected = true;
        tableactions_changes.selected = ctx2[0];
        add_flush_callback(() => updating_selected = false);
      }
      tableactions.$set(tableactions_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tableactions.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tableactions.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tableactions, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block9.name,
    type: "if",
    source: "(46:2) {#if actions.length > 0 && selected.length > 0}",
    ctx
  });
  return block;
}
function create_default_slot_13(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "stroke-width", "2");
      attr_dev(path, "d", "M15 19l-7-7 7-7");
      add_location(path, file17, 83, 4, 2071);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "h-3 w-3");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      add_location(svg, file17, 76, 3, 1932);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_13.name,
    type: "slot",
    source: "(70:2) <Button    round    disabled={page === 1}    on:click={() => {     gotoPage(page - 1);    }}   >",
    ctx
  });
  return block;
}
function create_default_slot5(ctx) {
  let svg;
  let path;
  const block = {
    c: function create() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr_dev(path, "stroke-linecap", "round");
      attr_dev(path, "stroke-linejoin", "round");
      attr_dev(path, "stroke-width", "2");
      attr_dev(path, "d", "M9 5l7 7-7 7");
      add_location(path, file17, 110, 4, 2869);
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr_dev(svg, "class", "h-3 w-3");
      attr_dev(svg, "fill", "none");
      attr_dev(svg, "viewBox", "0 0 24 24");
      attr_dev(svg, "stroke", "currentColor");
      add_location(svg, file17, 103, 3, 2730);
    },
    m: function mount(target, anchor) {
      insert_dev(target, svg, anchor);
      append_dev(svg, path);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(svg);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot5.name,
    type: "slot",
    source: "(97:2) <Button    round    disabled={page === numPages}    on:click={() => {     gotoPage(page + 1);    }}   >",
    ctx
  });
  return block;
}
function create_fragment18(ctx) {
  let div5;
  let div0;
  let t0;
  let div4;
  let div2;
  let t1;
  let div1;
  let select;
  let t2;
  let div3;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let button0;
  let t9;
  let input;
  let input_value_value;
  let t10;
  let button1;
  let current;
  let mounted;
  let dispose;
  let if_block = ctx[2].length > 0 && ctx[0].length > 0 && create_if_block9(ctx);
  select = new Select_default({
    props: {
      size: "small",
      options: ["10", "20", "50", "all"],
      value: ctx[5].toString()
    },
    $$inline: true
  });
  select.$on("change", ctx[14]);
  button0 = new Button_default({
    props: {
      round: true,
      disabled: ctx[3] === 1,
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button0.$on("click", ctx[15]);
  button1 = new Button_default({
    props: {
      round: true,
      disabled: ctx[3] === ctx[6],
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  button1.$on("click", ctx[17]);
  const block = {
    c: function create() {
      div5 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div4 = element("div");
      div2 = element("div");
      t1 = text("Items per page:\n			");
      div1 = element("div");
      create_component(select.$$.fragment);
      t2 = space();
      div3 = element("div");
      t3 = text(ctx[7]);
      t4 = text("-");
      t5 = text(ctx[8]);
      t6 = text(" of ");
      t7 = text(ctx[4]);
      t8 = space();
      create_component(button0.$$.fragment);
      t9 = space();
      input = element("input");
      t10 = space();
      create_component(button1.$$.fragment);
      attr_dev(div0, "class", "actions");
      add_location(div0, file17, 44, 1, 1199);
      attr_dev(div1, "class", "w-12 ml-2");
      add_location(div1, file17, 53, 3, 1459);
      attr_dev(div2, "class", "flex items-center mx-4");
      add_location(div2, file17, 51, 2, 1400);
      attr_dev(div3, "class", "mx-3");
      add_location(div3, file17, 66, 2, 1774);
      attr_dev(input, "class", "marcelle w-8 rounded mr-1 mb-1 bg-white text-gray-600 border border-solid border-gray-300 text-center focus:outline-none focus:ring-blue-400 focus:ring-2 focus:ring-opacity-50 active:ring-blue-400 active:ring-4 active:ring-opacity-50");
      input.value = input_value_value = ctx[3].toString();
      add_location(input, file17, 86, 2, 2188);
      attr_dev(div4, "class", "flex items-center");
      add_location(div4, file17, 50, 1, 1366);
      attr_dev(div5, "class", "table-footer svelte-13k2ee6");
      add_location(div5, file17, 43, 0, 1171);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div5, anchor);
      append_dev(div5, div0);
      if (if_block)
        if_block.m(div0, null);
      append_dev(div5, t0);
      append_dev(div5, div4);
      append_dev(div4, div2);
      append_dev(div2, t1);
      append_dev(div2, div1);
      mount_component(select, div1, null);
      append_dev(div4, t2);
      append_dev(div4, div3);
      append_dev(div3, t3);
      append_dev(div3, t4);
      append_dev(div3, t5);
      append_dev(div3, t6);
      append_dev(div3, t7);
      append_dev(div4, t8);
      mount_component(button0, div4, null);
      append_dev(div4, t9);
      append_dev(div4, input);
      append_dev(div4, t10);
      mount_component(button1, div4, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(input, "blur", ctx[16], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2].length > 0 && ctx2[0].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const select_changes = {};
      if (dirty & 32)
        select_changes.value = ctx2[5].toString();
      select.$set(select_changes);
      if (!current || dirty & 128)
        set_data_dev(t3, ctx2[7]);
      if (!current || dirty & 256)
        set_data_dev(t5, ctx2[8]);
      if (!current || dirty & 16)
        set_data_dev(t7, ctx2[4]);
      const button0_changes = {};
      if (dirty & 8)
        button0_changes.disabled = ctx2[3] === 1;
      if (dirty & 262144) {
        button0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button0.$set(button0_changes);
      if (!current || dirty & 8 && input_value_value !== (input_value_value = ctx2[3].toString()) && input.value !== input_value_value) {
        prop_dev(input, "value", input_value_value);
      }
      const button1_changes = {};
      if (dirty & 72)
        button1_changes.disabled = ctx2[3] === ctx2[6];
      if (dirty & 262144) {
        button1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      button1.$set(button1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(select.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(select.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div5);
      if (if_block)
        if_block.d();
      destroy_component(select);
      destroy_component(button0);
      destroy_component(button1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance18($$self, $$props, $$invalidate) {
  let itemsPerPage;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TableFooter", slots, []);
  let { provider } = $$props;
  let { actions } = $$props;
  let { selected } = $$props;
  let page = 1;
  let numPages = 1;
  let start = 0;
  let end = 0;
  let total = 0;
  let unsub = () => {
  };
  function gotoPage(i) {
    $$invalidate(3, page = i);
    provider.page(i);
  }
  $$self.$$.on_mount.push(function() {
    if (provider === void 0 && !("provider" in $$props || $$self.$$.bound[$$self.$$.props["provider"]])) {
      console.warn("<TableFooter> was created without expected prop 'provider'");
    }
    if (actions === void 0 && !("actions" in $$props || $$self.$$.bound[$$self.$$.props["actions"]])) {
      console.warn("<TableFooter> was created without expected prop 'actions'");
    }
    if (selected === void 0 && !("selected" in $$props || $$self.$$.bound[$$self.$$.props["selected"]])) {
      console.warn("<TableFooter> was created without expected prop 'selected'");
    }
  });
  const writable_props = ["provider", "actions", "selected"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TableFooter> was created with unknown prop '${key}'`);
  });
  function tableactions_selected_binding(value) {
    selected = value;
    $$invalidate(0, selected);
  }
  function selected_handler(event) {
    bubble.call(this, $$self, event);
  }
  function action_handler(event) {
    bubble.call(this, $$self, event);
  }
  const change_handler = ({ detail }) => {
    const n = detail === "all" ? total : parseInt(detail);
    provider.paginate(n);
    $$invalidate(5, itemsPerPage = n);
  };
  const click_handler = () => {
    gotoPage(page - 1);
  };
  const blur_handler = (e) => {
    let i = parseInt(e.currentTarget.value);
    if (isNaN(i))
      return;
    gotoPage(Math.max(1, Math.min(numPages, i)));
  };
  const click_handler_1 = () => {
    gotoPage(page + 1);
  };
  $$self.$$set = ($$props2) => {
    if ("provider" in $$props2)
      $$invalidate(1, provider = $$props2.provider);
    if ("actions" in $$props2)
      $$invalidate(2, actions = $$props2.actions);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
  };
  $$self.$capture_state = () => ({
    Button: Button_default,
    Select: Select_default,
    TableActions: TableActions_default,
    provider,
    actions,
    selected,
    page,
    numPages,
    start,
    end,
    total,
    unsub,
    gotoPage,
    itemsPerPage
  });
  $$self.$inject_state = ($$props2) => {
    if ("provider" in $$props2)
      $$invalidate(1, provider = $$props2.provider);
    if ("actions" in $$props2)
      $$invalidate(2, actions = $$props2.actions);
    if ("selected" in $$props2)
      $$invalidate(0, selected = $$props2.selected);
    if ("page" in $$props2)
      $$invalidate(3, page = $$props2.page);
    if ("numPages" in $$props2)
      $$invalidate(6, numPages = $$props2.numPages);
    if ("start" in $$props2)
      $$invalidate(7, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(8, end = $$props2.end);
    if ("total" in $$props2)
      $$invalidate(4, total = $$props2.total);
    if ("unsub" in $$props2)
      $$invalidate(10, unsub = $$props2.unsub);
    if ("itemsPerPage" in $$props2)
      $$invalidate(5, itemsPerPage = $$props2.itemsPerPage);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(5, itemsPerPage = provider.options.itemsPerPage);
    }
    if ($$self.$$.dirty & 1082) {
      $: {
        unsub();
        $$invalidate(10, unsub = provider.total.subscribe((t) => {
          if (t === void 0 || t === 0) {
            $$invalidate(6, numPages = 1);
            $$invalidate(7, start = 0);
            $$invalidate(8, end = 0);
            $$invalidate(4, total = 0);
          } else {
            $$invalidate(6, numPages = Math.ceil(total / itemsPerPage));
            $$invalidate(7, start = (page - 1) * itemsPerPage + 1);
            $$invalidate(8, end = Math.min(total || 0, page * itemsPerPage));
            $$invalidate(4, total = t);
          }
        }));
      }
    }
  };
  return [
    selected,
    provider,
    actions,
    page,
    total,
    itemsPerPage,
    numPages,
    start,
    end,
    gotoPage,
    unsub,
    tableactions_selected_binding,
    selected_handler,
    action_handler,
    change_handler,
    click_handler,
    blur_handler,
    click_handler_1
  ];
}
var TableFooter = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance18, create_fragment18, safe_not_equal, { provider: 1, actions: 2, selected: 0 }, add_css14);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TableFooter",
      options,
      id: create_fragment18.name
    });
  }
  get provider() {
    throw new Error("<TableFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set provider(value) {
    throw new Error("<TableFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actions() {
    throw new Error("<TableFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actions(value) {
    throw new Error("<TableFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<TableFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<TableFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TableFooter_default = TableFooter;

// node_modules/@marcellejs/design-system/dist/Table.svelte
var file18 = "node_modules/@marcellejs/design-system/dist/Table.svelte";
function add_css15(target) {
  append_styles(target, "svelte-12gp9na", ".table-container.svelte-12gp9na.svelte-12gp9na.svelte-12gp9na{display:flex;width:100%;flex-direction:column;font-size:0.8rem;border:1px solid rgb(229, 231, 235);border-radius:0.5rem;overflow:scroll}table.svelte-12gp9na.svelte-12gp9na.svelte-12gp9na{min-width:100%;border-collapse:collapse}thead.svelte-12gp9na.svelte-12gp9na.svelte-12gp9na{background-color:rgb(249, 250, 251)}thead.svelte-12gp9na tr.svelte-12gp9na.svelte-12gp9na{width:100%}thead.svelte-12gp9na tr th.svelte-12gp9na.svelte-12gp9na{text-align:left;padding-left:1rem;padding-right:1rem;padding-top:0.75rem;padding-bottom:0.75rem;line-height:1rem;font-weight:500;color:rgb(107, 114, 128);letter-spacing:0.05em}tbody.svelte-12gp9na.svelte-12gp9na.svelte-12gp9na{background-color:white}tbody.svelte-12gp9na>.svelte-12gp9na:not([hidden])~.svelte-12gp9na:not([hidden]){border-top:1px solid rgb(229, 231, 235)}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFibGUuc3ZlbHRlIiwibWFwcGluZ3MiOiJBQTJIQyxnQkFBZ0IsNkNBQUMsQ0FBQSxBQUNoQixPQUFPLENBQUUsSUFBSSxDQUNiLEtBQUssQ0FBRSxJQUFJLENBQ1gsY0FBYyxDQUFFLE1BQU0sQ0FDdEIsU0FBUyxDQUFFLE1BQU0sQ0FDakIsTUFBTSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FDcEMsYUFBYSxDQUFFLE1BQU0sQ0FDckIsUUFBUSxDQUFFLE1BQU0sQUFDakIsQ0FBQSxBQUVBLEtBQUssNkNBQUMsQ0FBQSxBQUNMLFNBQVMsQ0FBRSxJQUFJLENBQ2YsZUFBZSxDQUFFLFFBQVEsQUFDMUIsQ0FBQSxBQUVBLEtBQUssNkNBQUMsQ0FBQSxBQUNMLGdCQUFnQixDQUFFLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEFBQ3JDLENBQUEsQUFFQSxvQkFBSyxDQUFDLEVBQUUsOEJBQUMsQ0FBQSxBQUNSLEtBQUssQ0FBRSxJQUFJLEFBQ1osQ0FBQSxBQUVBLG9CQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsOEJBQUMsQ0FBQSxBQUNYLFVBQVUsQ0FBRSxJQUFJLENBQ2hCLFlBQVksQ0FBRSxJQUFJLENBQ2xCLGFBQWEsQ0FBRSxJQUFJLENBQ25CLFdBQVcsQ0FBRSxPQUFPLENBQ3BCLGNBQWMsQ0FBRSxPQUFPLENBQ3ZCLFdBQVcsQ0FBRSxJQUFJLENBQ2pCLFdBQVcsQ0FBRSxHQUFHLENBQ2hCLEtBQUssQ0FBRSxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUN6QixjQUFjLENBQUUsTUFBTSxBQUN2QixDQUFBLEFBRUEsS0FBSyw2Q0FBQyxDQUFBLEFBQ0wsZ0JBQWdCLENBQUUsS0FBSyxBQUN4QixDQUFBLEFBRUEsb0JBQUssZ0JBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDLGdCQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxBQUFDLENBQUEsQUFDdkMsVUFBVSxDQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQUFDekMsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJUYWJsZS5zdmVsdGUiXX0= */");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i];
  child_ctx[24] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i].type;
  child_ctx[26] = list[i].name;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i].name;
  child_ctx[29] = list[i].sortable;
  return child_ctx;
}
function create_if_block_32(ctx) {
  let div;
  let sl_alert;
  let sl_icon;
  let t0;
  let strong;
  let br;
  let t2;
  let t3;
  const block = {
    c: function create() {
      div = element("div");
      sl_alert = element("sl-alert");
      sl_icon = element("sl-icon");
      t0 = space();
      strong = element("strong");
      strong.textContent = "Table Data Error";
      br = element("br");
      t2 = space();
      t3 = text(ctx[9]);
      set_custom_element_data(sl_icon, "slot", "icon");
      set_custom_element_data(sl_icon, "name", "check2-circle");
      add_location(sl_icon, file18, 63, 3, 1845);
      add_location(strong, file18, 64, 3, 1893);
      add_location(br, file18, 64, 36, 1926);
      set_custom_element_data(sl_alert, "type", "danger");
      set_custom_element_data(sl_alert, "open", "");
      add_location(sl_alert, file18, 62, 2, 1812);
      attr_dev(div, "class", "service-error");
      add_location(div, file18, 61, 1, 1782);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, sl_alert);
      append_dev(sl_alert, sl_icon);
      append_dev(sl_alert, t0);
      append_dev(sl_alert, strong);
      append_dev(sl_alert, br);
      append_dev(sl_alert, t2);
      append_dev(sl_alert, t3);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 512)
        set_data_dev(t3, ctx2[9]);
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_32.name,
    type: "if",
    source: "(61:0) {#if $error}",
    ctx
  });
  return block;
}
function create_if_block_14(ctx) {
  let th;
  let if_block = !ctx[4] && create_if_block_22(ctx);
  const block = {
    c: function create() {
      th = element("th");
      if (if_block)
        if_block.c();
      attr_dev(th, "class", "svelte-12gp9na");
      add_location(th, file18, 74, 5, 2065);
    },
    m: function mount(target, anchor) {
      insert_dev(target, th, anchor);
      if (if_block)
        if_block.m(th, null);
    },
    p: function update(ctx2, dirty) {
      if (!ctx2[4]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_22(ctx2);
          if_block.c();
          if_block.m(th, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(th);
      if (if_block)
        if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_14.name,
    type: "if",
    source: "(74:4) {#if selectable}",
    ctx
  });
  return block;
}
function create_if_block_22(ctx) {
  let input;
  let input_checked_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      input = element("input");
      attr_dev(input, "type", "checkbox");
      input.checked = input_checked_value = ctx[6].length > 0 && ctx[6].length === ctx[10].length;
      add_location(input, file18, 76, 7, 2106);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(input, "click", ctx[12], false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & 1088 && input_checked_value !== (input_checked_value = ctx2[6].length > 0 && ctx2[6].length === ctx2[10].length)) {
        prop_dev(input, "checked", input_checked_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_22.name,
    type: "if",
    source: "(76:6) {#if !singleSelection}",
    ctx
  });
  return block;
}
function create_each_block_2(ctx) {
  let tableheadercell;
  let current;
  tableheadercell = new TableHeaderCell_default({
    props: {
      name: ctx[26],
      sortable: ctx[29],
      sorting: ctx[7]
    },
    $$inline: true
  });
  tableheadercell.$on("sort", ctx[11]);
  const block = {
    c: function create() {
      create_component(tableheadercell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tableheadercell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tableheadercell_changes = {};
      if (dirty[0] & 1)
        tableheadercell_changes.name = ctx2[26];
      if (dirty[0] & 1)
        tableheadercell_changes.sortable = ctx2[29];
      if (dirty[0] & 128)
        tableheadercell_changes.sorting = ctx2[7];
      tableheadercell.$set(tableheadercell_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tableheadercell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tableheadercell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tableheadercell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(85:4) {#each columns as { name, sortable }}",
    ctx
  });
  return block;
}
function create_if_block10(ctx) {
  let tablecontentcell;
  let current;
  tablecontentcell = new TableContentCell_default({
    props: {
      type: "slot",
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(tablecontentcell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablecontentcell, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tablecontentcell_changes = {};
      if (dirty[0] & 64 | dirty[1] & 2) {
        tablecontentcell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tablecontentcell.$set(tablecontentcell_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablecontentcell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecontentcell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecontentcell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block10.name,
    type: "if",
    source: "(93:5) {#if selectable}",
    ctx
  });
  return block;
}
function create_default_slot6(ctx) {
  let input;
  let input_checked_value;
  let mounted;
  let dispose;
  function click_handler(...args) {
    return ctx[16](ctx[24], ...args);
  }
  const block = {
    c: function create() {
      input = element("input");
      attr_dev(input, "type", "checkbox");
      input.checked = input_checked_value = ctx[6].includes(ctx[24]);
      add_location(input, file18, 94, 7, 2538);
    },
    m: function mount(target, anchor) {
      insert_dev(target, input, anchor);
      if (!mounted) {
        dispose = listen_dev(input, "click", click_handler, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & 64 && input_checked_value !== (input_checked_value = ctx[6].includes(ctx[24]))) {
        prop_dev(input, "checked", input_checked_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(input);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot6.name,
    type: "slot",
    source: '(94:6) <TableContentCell type=\\"slot\\">',
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let tablecontentcell;
  let current;
  function action_handler(...args) {
    return ctx[17](ctx[24], ...args);
  }
  tablecontentcell = new TableContentCell_default({
    props: {
      type: ctx[25],
      value: ctx[22][ctx[26]]
    },
    $$inline: true
  });
  tablecontentcell.$on("action", action_handler);
  const block = {
    c: function create() {
      create_component(tablecontentcell.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(tablecontentcell, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tablecontentcell_changes = {};
      if (dirty[0] & 1)
        tablecontentcell_changes.type = ctx[25];
      if (dirty[0] & 1025)
        tablecontentcell_changes.value = ctx[22][ctx[26]];
      tablecontentcell.$set(tablecontentcell_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tablecontentcell.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tablecontentcell.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(tablecontentcell, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(102:5) {#each columns as { type, name }}",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let tr;
  let t0;
  let t1;
  let current;
  let if_block = ctx[3] && create_if_block10(ctx);
  let each_value_1 = ctx[0];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      tr = element("tr");
      if (if_block)
        if_block.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      attr_dev(tr, "class", "svelte-12gp9na");
      add_location(tr, file18, 91, 4, 2467);
    },
    m: function mount(target, anchor) {
      insert_dev(target, tr, anchor);
      if (if_block)
        if_block.m(tr, null);
      append_dev(tr, t0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tr, null);
      }
      append_dev(tr, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & 8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block10(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(tr, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & 17409) {
        each_value_1 = ctx2[0];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tr, t1);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(tr);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(91:3) {#each $data as item, i}",
    ctx
  });
  return block;
}
function create_fragment19(ctx) {
  let t0;
  let div;
  let table;
  let thead;
  let tr;
  let t1;
  let t2;
  let tbody;
  let t3;
  let tablefooter;
  let updating_selected;
  let current;
  let if_block0 = ctx[9] && create_if_block_32(ctx);
  let if_block1 = ctx[3] && create_if_block_14(ctx);
  let each_value_2 = ctx[0];
  validate_each_argument(each_value_2);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value = ctx[10];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  function tablefooter_selected_binding(value) {
    ctx[18](value);
  }
  let tablefooter_props = {
    provider: ctx[1],
    actions: ctx[2]
  };
  if (ctx[6] !== void 0) {
    tablefooter_props.selected = ctx[6];
  }
  tablefooter = new TableFooter_default({ props: tablefooter_props, $$inline: true });
  binding_callbacks.push(() => bind(tablefooter, "selected", tablefooter_selected_binding));
  tablefooter.$on("action", ctx[19]);
  const block = {
    c: function create() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      div = element("div");
      table = element("table");
      thead = element("thead");
      tr = element("tr");
      if (if_block1)
        if_block1.c();
      t1 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      tbody = element("tbody");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      create_component(tablefooter.$$.fragment);
      attr_dev(tr, "class", "svelte-12gp9na");
      add_location(tr, file18, 72, 3, 2034);
      attr_dev(thead, "class", "svelte-12gp9na");
      add_location(thead, file18, 71, 2, 2023);
      attr_dev(tbody, "class", "svelte-12gp9na");
      add_location(tbody, file18, 89, 2, 2427);
      attr_dev(table, "class", "svelte-12gp9na");
      add_location(table, file18, 70, 1, 2013);
      attr_dev(div, "class", "marcelle table-container svelte-12gp9na");
      add_location(div, file18, 69, 0, 1973);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert_dev(target, t0, anchor);
      insert_dev(target, div, anchor);
      append_dev(div, table);
      append_dev(table, thead);
      append_dev(thead, tr);
      if (if_block1)
        if_block1.m(tr, null);
      append_dev(tr, t1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(tr, null);
      }
      append_dev(table, t2);
      append_dev(table, tbody);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(tbody, null);
      }
      append_dev(div, t3);
      mount_component(tablefooter, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (ctx2[9]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[3]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_14(ctx2);
          if_block1.c();
          if_block1.m(tr, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & 2177) {
        each_value_2 = ctx2[0];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_2(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(tr, null);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & 25673) {
        each_value = ctx2[10];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(tbody, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
      const tablefooter_changes = {};
      if (dirty[0] & 2)
        tablefooter_changes.provider = ctx2[1];
      if (dirty[0] & 4)
        tablefooter_changes.actions = ctx2[2];
      if (!updating_selected && dirty[0] & 64) {
        updating_selected = true;
        tablefooter_changes.selected = ctx2[6];
        add_flush_callback(() => updating_selected = false);
      }
      tablefooter.$set(tablefooter_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(tablefooter.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(tablefooter.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach_dev(t0);
      if (detaching)
        detach_dev(div);
      if (if_block1)
        if_block1.d();
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      destroy_component(tablefooter);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance19($$self, $$props, $$invalidate) {
  let data;
  let error;
  let $error, $$unsubscribe_error = noop, $$subscribe_error = () => ($$unsubscribe_error(), $$unsubscribe_error = subscribe(error, ($$value) => $$invalidate(9, $error = $$value)), error);
  let $data, $$unsubscribe_data = noop, $$subscribe_data = () => ($$unsubscribe_data(), $$unsubscribe_data = subscribe(data, ($$value) => $$invalidate(10, $data = $$value)), data);
  $$self.$$.on_destroy.push(() => $$unsubscribe_error());
  $$self.$$.on_destroy.push(() => $$unsubscribe_data());
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Table", slots, []);
  let { columns } = $$props;
  let { provider } = $$props;
  let { actions = [] } = $$props;
  let { selectable = true } = $$props;
  let { singleSelection = false } = $$props;
  let { selection = [] } = $$props;
  let selected = [];
  const dispatch = createEventDispatcher();
  let sorting = { col: "", ascending: true };
  function sort({ detail }) {
    $$invalidate(7, sorting = detail);
    provider.sort(detail);
  }
  async function dispatchSelection() {
    $$invalidate(15, selection = await Promise.all(selected.map(provider.get.bind(provider))));
    dispatch("selection", selection);
  }
  function selectAll() {
    if (selected.length === get_store_value(data).length) {
      $$invalidate(6, selected = []);
    } else {
      $$invalidate(6, selected = get_store_value(data).map((x, i) => i));
    }
    dispatchSelection();
  }
  function selectOne(index, e) {
    if (singleSelection) {
      $$invalidate(6, selected = e.currentTarget.checked ? [index] : []);
      dispatchSelection();
    } else {
      if (e.currentTarget.checked) {
        if (!selected.includes(index)) {
          $$invalidate(6, selected = selected.concat([index]));
          dispatchSelection();
        }
      } else {
        $$invalidate(6, selected = selected.filter((x) => x !== index));
        dispatchSelection();
      }
    }
  }
  async function propagateAction([actionName, sel]) {
    const s = Array.isArray(sel) ? await Promise.all(sel.map(provider.get.bind(provider))) : await provider.get(sel);
    dispatch(actionName, s);
  }
  $$self.$$.on_mount.push(function() {
    if (columns === void 0 && !("columns" in $$props || $$self.$$.bound[$$self.$$.props["columns"]])) {
      console.warn("<Table> was created without expected prop 'columns'");
    }
    if (provider === void 0 && !("provider" in $$props || $$self.$$.bound[$$self.$$.props["provider"]])) {
      console.warn("<Table> was created without expected prop 'provider'");
    }
  });
  const writable_props = ["columns", "provider", "actions", "selectable", "singleSelection", "selection"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Table> was created with unknown prop '${key}'`);
  });
  const click_handler = (i, e) => selectOne(i, e);
  const action_handler = (i, { detail }) => {
    propagateAction([detail, i]);
  };
  function tablefooter_selected_binding(value) {
    selected = value;
    $$invalidate(6, selected), $$invalidate(15, selection), $$invalidate(5, data), $$invalidate(1, provider);
  }
  const action_handler_1 = ({ detail }) => propagateAction(detail);
  $$self.$$set = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("provider" in $$props2)
      $$invalidate(1, provider = $$props2.provider);
    if ("actions" in $$props2)
      $$invalidate(2, actions = $$props2.actions);
    if ("selectable" in $$props2)
      $$invalidate(3, selectable = $$props2.selectable);
    if ("singleSelection" in $$props2)
      $$invalidate(4, singleSelection = $$props2.singleSelection);
    if ("selection" in $$props2)
      $$invalidate(15, selection = $$props2.selection);
  };
  $$self.$capture_state = () => ({
    createEventDispatcher,
    TableContentCell: TableContentCell_default,
    TableHeaderCell: TableHeaderCell_default,
    TableFooter: TableFooter_default,
    get: get_store_value,
    columns,
    provider,
    actions,
    selectable,
    singleSelection,
    selection,
    selected,
    dispatch,
    sorting,
    sort,
    dispatchSelection,
    selectAll,
    selectOne,
    propagateAction,
    data,
    error,
    $error,
    $data
  });
  $$self.$inject_state = ($$props2) => {
    if ("columns" in $$props2)
      $$invalidate(0, columns = $$props2.columns);
    if ("provider" in $$props2)
      $$invalidate(1, provider = $$props2.provider);
    if ("actions" in $$props2)
      $$invalidate(2, actions = $$props2.actions);
    if ("selectable" in $$props2)
      $$invalidate(3, selectable = $$props2.selectable);
    if ("singleSelection" in $$props2)
      $$invalidate(4, singleSelection = $$props2.singleSelection);
    if ("selection" in $$props2)
      $$invalidate(15, selection = $$props2.selection);
    if ("selected" in $$props2)
      $$invalidate(6, selected = $$props2.selected);
    if ("sorting" in $$props2)
      $$invalidate(7, sorting = $$props2.sorting);
    if ("data" in $$props2)
      $$subscribe_data($$invalidate(5, data = $$props2.data));
    if ("error" in $$props2)
      $$subscribe_error($$invalidate(8, error = $$props2.error));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$subscribe_data($$invalidate(5, data = provider.data));
    }
    if ($$self.$$.dirty[0] & 2) {
      $:
        $$subscribe_error($$invalidate(8, error = provider.error));
    }
    if ($$self.$$.dirty[0] & 32800) {
      $:
        $$invalidate(6, selected = selection.map((x) => get_store_value(data).indexOf(x)));
    }
  };
  return [
    columns,
    provider,
    actions,
    selectable,
    singleSelection,
    data,
    selected,
    sorting,
    error,
    $error,
    $data,
    sort,
    selectAll,
    selectOne,
    propagateAction,
    selection,
    click_handler,
    action_handler,
    tablefooter_selected_binding,
    action_handler_1
  ];
}
var Table = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance19,
      create_fragment19,
      safe_not_equal,
      {
        columns: 0,
        provider: 1,
        actions: 2,
        selectable: 3,
        singleSelection: 4,
        selection: 15
      },
      add_css15,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment19.name
    });
  }
  get columns() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columns(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get provider() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set provider(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get actions() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set actions(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectable() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectable(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get singleSelection() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set singleSelection(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selection() {
    throw new Error("<Table>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selection(value) {
    throw new Error("<Table>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Table_default = Table;

// node_modules/@marcellejs/design-system/dist/TabList.svelte
var file19 = "node_modules/@marcellejs/design-system/dist/TabList.svelte";
function create_fragment20(ctx) {
  let div;
  let current;
  const default_slot_template = ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[0], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      attr_dev(div, "class", "flex border-solid border-0 border-b border-gray-200 mb-2");
      add_location(div, file19, 0, 0, 0);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 1)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[0],
            !current ? get_all_dirty_from_scope(ctx2[0]) : get_slot_changes(default_slot_template, ctx2[0], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance20($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabList", slots, ["default"]);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<TabList> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(0, $$scope = $$props2.$$scope);
  };
  return [$$scope, slots];
}
var TabList = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance20, create_fragment20, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabList",
      options,
      id: create_fragment20.name
    });
  }
};
var TabList_default = TabList;

// node_modules/@marcellejs/design-system/dist/table-abstract-provider.js
var defaultOptions = { itemsPerPage: 10 };
var TableDataProvider = class {
  constructor(options = defaultOptions) {
    __publicField(this, "options");
    __publicField(this, "data", writable([]));
    __publicField(this, "total", writable(0));
    __publicField(this, "error", writable(null));
    this.options = { ...defaultOptions, ...options };
  }
  paginate(n) {
    this.options.itemsPerPage = n;
    this.update();
  }
  async get(i) {
    const data = get_store_value(this.data);
    if (i >= 0 && i < data.length) {
      return data[i];
    }
    return null;
  }
};

// node_modules/@marcellejs/design-system/dist/table-array-provider.js
var TableArrayProvider = class extends TableDataProvider {
  constructor({ data, ...options }) {
    super(options);
    __publicField(this, "rawData");
    __publicField(this, "currentPage", 1);
    this.rawData = data;
    this.total.set(data.length);
    this.data.set(this.rawData.slice(0, this.options.itemsPerPage));
  }
  async update() {
    this.page(this.currentPage);
  }
  async page(i) {
    this.data.set(this.rawData.slice((i - 1) * this.options.itemsPerPage, Math.min(i * this.options.itemsPerPage, this.rawData.length)));
    this.currentPage = i;
  }
  async sort(sorting) {
    this.rawData.sort((x, y) => {
      if (x[sorting.col] > y[sorting.col])
        return sorting.ascending ? 1 : -1;
      if (x[sorting.col] < y[sorting.col])
        return sorting.ascending ? -1 : 1;
      return 0;
    });
    this.page(this.currentPage);
  }
  async delete(i) {
    this.rawData.splice(i, 1);
    this.page(this.currentPage);
    return null;
  }
};

// node_modules/@marcellejs/design-system/dist/table-service-provider.js
var TableServiceProvider = class extends TableDataProvider {
  constructor({ service, columns, transform, ...options }) {
    super(options);
    __publicField(this, "service");
    __publicField(this, "query");
    __publicField(this, "transform");
    this.service = service;
    this.transform = transform || {};
    this.query = {
      $sort: {
        updatedAt: -1
      },
      $limit: this.options.itemsPerPage
    };
    if (columns) {
      this.query.$select = columns.map((x) => x.name).concat(["id"]);
    }
    this.update();
    this.service.on("created", this.update.bind(this));
    this.service.on("patched", this.update.bind(this));
    this.service.on("updated", this.update.bind(this));
    this.service.on("removed", this.update.bind(this));
  }
  paginate(n) {
    super.paginate(n);
    this.query.$limit = this.options.itemsPerPage;
    this.update();
  }
  async update() {
    try {
      const res = await this.service.find({ query: this.query });
      const data = res.data.map((x, i) => {
        const z = Object.entries(this.transform).map(([target, f]) => {
          try {
            return { [target]: f(x, i) };
          } catch (error) {
            return { [target]: "transform error" };
          }
        }).reduce((o, y) => ({ ...o, ...y }), {});
        return { ...x, ...z };
      });
      this.data.set(data);
      this.total.set(res.total);
      this.error.set(null);
    } catch (error) {
      this.data.set([]);
      this.total.set(0);
      this.error.set(error);
    }
  }
  async page(i) {
    this.query.$skip = (i - 1) * this.query.$limit;
    this.update();
  }
  async sort(sorting) {
    const { col, ascending } = sorting;
    if (col) {
      this.query.$sort = {
        [col]: ascending ? 1 : -1
      };
    } else {
      delete this.query.$sort;
    }
    this.update();
  }
  async delete(i) {
    const removed = get_store_value(this.data)[i];
    await this.service.remove(removed.id);
    this.update();
    return removed;
  }
};

// node_modules/@marcellejs/design-system/dist/ViewContainer.svelte
var file20 = "node_modules/@marcellejs/design-system/dist/ViewContainer.svelte";
function add_css16(target) {
  append_styles(target, "svelte-xnhseh", ".card-container.svelte-xnhseh{display:flex;width:100%;flex-grow:1;flex-direction:column;justify-content:flex-start\n}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlld0NvbnRhaW5lci5zdmVsdGUiLCJtYXBwaW5ncyI6IkFBcUJFLGVBQWUsY0FBQyxDQUFBLEFBQ2QsT0FBTyxDQUFFLElBQUksQ0FDYixLQUFLLENBQUUsSUFBSSxDQUNYLFNBQVMsQ0FBRSxDQUFDLENBQ1osY0FBYyxDQUFFLE1BQU0sQ0FDdEIsZUFBZSxDQUFFLFVBQUs7QUFDMUIsQ0FBQyIsIm5hbWVzIjpbXSwic291cmNlcyI6WyJWaWV3Q29udGFpbmVyLnN2ZWx0ZSJdfQ== */");
}
function create_if_block_15(ctx) {
  let div;
  let progress_1;
  let current;
  progress_1 = new Progress_default({
    props: {
      progress: ctx[2],
      thin: true
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(progress_1.$$.fragment);
      attr_dev(div, "class", "absolute top-0 left-0 right-0");
      add_location(div, file20, 9, 4, 236);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(progress_1, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const progress_1_changes = {};
      if (dirty & 4)
        progress_1_changes.progress = ctx2[2];
      progress_1.$set(progress_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(progress_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(progress_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(progress_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_15.name,
    type: "if",
    source: "(9:2) {#if progress !== false}",
    ctx
  });
  return block;
}
function create_if_block11(ctx) {
  let spinner;
  let current;
  spinner = new Spinner_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(spinner.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(spinner, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(spinner.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(spinner.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(spinner, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block11.name,
    type: "if",
    source: "(15:2) {#if loading}",
    ctx
  });
  return block;
}
function create_fragment21(ctx) {
  let div;
  let t0;
  let span;
  let t1;
  let t2;
  let t3;
  let current;
  let if_block0 = ctx[2] !== false && create_if_block_15(ctx);
  let if_block1 = ctx[1] && create_if_block11(ctx);
  const default_slot_template = ctx[4].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[3], null);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      span = element("span");
      t1 = text(ctx[0]);
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (default_slot)
        default_slot.c();
      attr_dev(span, "class", "card-title");
      add_location(span, file20, 13, 2, 336);
      attr_dev(div, "class", "card-container svelte-xnhseh");
      add_location(div, file20, 7, 0, 176);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append_dev(div, t0);
      append_dev(div, span);
      append_dev(span, t1);
      append_dev(div, t2);
      if (if_block1)
        if_block1.m(div, null);
      append_dev(div, t3);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (ctx2[2] !== false) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_15(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (!current || dirty & 1)
        set_data_dev(t1, ctx2[0]);
      if (ctx2[1]) {
        if (if_block1) {
          if (dirty & 2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block11(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[3],
            !current ? get_all_dirty_from_scope(ctx2[3]) : get_slot_changes(default_slot_template, ctx2[3], dirty, null),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance21($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("ViewContainer", slots, ["default"]);
  let { title } = $$props;
  let { loading = false } = $$props;
  let { progress = false } = $$props;
  $$self.$$.on_mount.push(function() {
    if (title === void 0 && !("title" in $$props || $$self.$$.bound[$$self.$$.props["title"]])) {
      console.warn("<ViewContainer> was created without expected prop 'title'");
    }
  });
  const writable_props = ["title", "loading", "progress"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<ViewContainer> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("progress" in $$props2)
      $$invalidate(2, progress = $$props2.progress);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    Spinner: Spinner_default,
    Progress: Progress_default,
    title,
    loading,
    progress
  });
  $$self.$inject_state = ($$props2) => {
    if ("title" in $$props2)
      $$invalidate(0, title = $$props2.title);
    if ("loading" in $$props2)
      $$invalidate(1, loading = $$props2.loading);
    if ("progress" in $$props2)
      $$invalidate(2, progress = $$props2.progress);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [title, loading, progress, $$scope, slots];
}
var ViewContainer = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance21, create_fragment21, safe_not_equal, { title: 0, loading: 1, progress: 2 }, add_css16);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewContainer",
      options,
      id: create_fragment21.name
    });
  }
  get title() {
    throw new Error("<ViewContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ViewContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get loading() {
    throw new Error("<ViewContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set loading(value) {
    throw new Error("<ViewContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get progress() {
    throw new Error("<ViewContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<ViewContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var ViewContainer_default = ViewContainer;
export {
  Button_default as Button,
  Input_default as Input,
  Modal_default as Modal,
  Notification_default as Notification,
  Number_default as Number,
  NumberArray_default as NumberArray,
  PopMenu_default as PopMenu,
  Progress_default as Progress,
  Select_default as Select,
  Spinner_default as Spinner,
  Switch_default as Switch,
  Tab_default as Tab,
  TabList_default as TabList,
  TabPanel_default as TabPanel,
  Table_default as Table,
  TableArrayProvider,
  TableDataProvider,
  TableServiceProvider,
  Tabs_default as Tabs,
  ViewContainer_default as ViewContainer
};
//# sourceMappingURL=@marcellejs_design-system.js.map
